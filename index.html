<!doctype html>
<html lang='en'>

<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <title>Galaxy Spectra Redshift Viewer</title>
  <style>
    :root {
      color-scheme: dark light;
    }

    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #0b0b0b;
      color: #e5e5e5;
    }

    header,
    footer {
      padding: 8px 12px;
      background: #111;
      border-bottom: 1px solid #222;
    }

    footer {
      border-top: 1px solid #222;
      border-bottom: none;
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    button,
    select,
    input {
      background: #181818;
      color: #ddd;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 6px 8px;
    }

    #canvas {
      display: block;
      width: 100vw;
      height: calc(100vh - 150px);
      background: #0a0a0a;
      touch-action: none;
    }

    .pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #333;
      background: #151515;
    }

    #legend {
      font-size: 12px;
    }

    /* overlay */

    #cutoutWrap {
      position: fixed;
      right: 12px;
      bottom: 12px;
      width: 280px;
      height: 280px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #000;
      z-index: 20;
      overflow: hidden;
    }

    #cutout {
      width: 100%;
      height: 100%;
      object-fit: contain;

      opacity: .9;
      pointer-events: none;
    }

    #cutoutCaption {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 6px 10px;
      font: 600 12px/1.2 system-ui, sans-serif;
      color: #eee;
      text-align: right;
      /* bottom-right, per your spec */
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-shadow: 0 1px 2px rgba(0, 0, 0, .7);
      background: linear-gradient(to top, rgba(0, 0, 0, .55), rgba(0, 0, 0, 0));
      pointer-events: none;
    }

    #mapOverlay {
      position: fixed;
      inset: 0;
      z-index: 1000;
      background: rgba(0, 0, 0, .88);
    }

    #map3d {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      cursor: grab;
    }

    #map3d:active {
      cursor: grabbing;
    }

    #mapClose {
      position: absolute;
      top: 12px;
      right: 12px;
      background: #181818;
      color: #ddd;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 6px 10px;
    }

    #mapOverlay {
      position: fixed;
      inset: 0;
      z-index: 1000;
      background: rgba(0, 0, 0, .88);
      display: none;
    }

    #map3d {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      cursor: grab;
      z-index: 0;
      touch-action: none;
      /* disable browser panning/zoom so we handle it */
    }

    #map3d:active {
      cursor: grabbing;
    }

    #mapControls {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 2;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border: 1px solid #333;
      border-radius: 10px;
      color: #ddd;
      background: rgba(20, 20, 20, .85);
      backdrop-filter: blur(4px);
    }

    #mapControls label {
      display: flex;
      align-items: center;
      gap: 8px;
      font: 500 13px system-ui, sans-serif;
    }

    #mapControls input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: #5aa7ff;
    }

    #mapClose {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 2;
    }
  </style>

</head>

<body>
  <header>
    <div class='row'>
      <label>Object</label><select id='obj'></select>
      <label>Mode</label>
      <select id='mode'>
        <option value='observed'>Observed</option>
        <option value='rest'>Rest-frame (divide by 1+z)</option>
      </select>
      <label>z</label><input id='z' type='number' step='0.0001' value='0' style='width:110px'>
      <button id='applyZ'>Apply z</button>
      <button id='open'>Open JSON…</button>
      <span class='pill' id='status'>No file loaded</span>
    </div>
    <label>Scaling</label>
    <select id="yscale">
      <option value="auto">Auto</option>
      <option value="abs" selected>Absolute</option>
    </select>
    <label>Flux scale</label>
    <input id="gain" type="range" min="0.01" max="2" step="0.01" value="0.50">
    <output id="gainOut" class="pill">×0.50</output>
    <label><input id="showLines" type="checkbox"> Show element lines</label>
    <button id="showMap">Show Map</button>
  </header>
  <canvas id='canvas'></canvas>
  <style>

  </style>
  <footer>
    <div class='row'>
      <div id='legend'></div>
      <div style='margin-left:auto'><span class='pill'>Vertical lines: key rest wavelengths</span></div>
    </div>
  </footer>
  <input type='file' id='file' accept='.json' style='display:none'>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const objSel = document.getElementById('obj');
    const modeSel = document.getElementById('mode');
    const zInput = document.getElementById('z');
    const applyZBtn = document.getElementById('applyZ');
    const statusEl = document.getElementById('status');
    const openBtn = document.getElementById('open');
    const fileIn = document.getElementById('file');
    const legend = document.getElementById('legend');
    let hoverNm = null, hoverYpx = null;  // current hover wavelength in nm (or null)

    // ---- wavelength scale (draggable) ----
    let scaleY = null;           // pixel Y of the scale baseline; null ⇒ default at B
    let draggingScale = false;
    let scaleGrabOffset = 0;     // mouse Y offset when grabbing the scale


    const REST_LINES = [
      //["[O II]", 3727.0],
      ["Hδ", 4101.74],
      ["Hγ", 4340.47],
      ["Hβ", 4861.33],
      //["[O III]", 4958.91],
      //["[O III]", 5006.84],
      ["Mg b", 5175.0],
      ["Na D", 5891.58],
      ["Hα", 6562.80],
      //["[N II]", 6583.45],
      //["[S II]", 6716.44],
      //["[S II]", 6730.82],
      //["Ca K", 3933.66],
      //["Ca H", 3968.47],
    ];
    const A2NM = 0.1;

    let data = []; let view = { xlo: 3500, xhi: 9000, ylo: -1, yhi: 5 }; let current = 0;

    const yScaleSel = document.getElementById('yscale');
    const gain = document.getElementById('gain');
    const gainOut = document.getElementById('gainOut');

    // --- ABS envelope (fixed y-window, center-locked) ---
    let GLOBAL = { med: 0, mad: 1, qlo: 0, qhi: 0 };
    let ABS_BASE_R = 1;               // half-height in transformed units
    const ABS_PAD_FRAC = 0.20;

    function computeGlobalStats() {
      const all = data.flatMap(d => d.flux || []);
      if (!all.length) { GLOBAL = { med: 0, mad: 1, qlo: -1, qhi: 1 }; ABS_BASE_R = 1; return; }
      const m = median(all);
      const mad = median(all.map(v => Math.abs(v - m))) || 1;
      const qlo = percentile(all, 0.001);
      const qhi = percentile(all, 0.999);
      GLOBAL = { med: m, mad, qlo, qhi };
      // compute fixed y envelope from global extremes in asinh space
      const s0 = 3 * GLOBAL.mad;
      const y0lo = Math.asinh((GLOBAL.qlo - GLOBAL.med) / s0);
      const y0hi = Math.asinh((GLOBAL.qhi - GLOBAL.med) / s0);
      ABS_BASE_R = Math.max(Math.abs(y0lo), Math.abs(y0hi)) || 1;
    }

    function updateAbsYRange() {
      const half = ABS_BASE_R * (1 + ABS_PAD_FRAC);  // fixed, independent of slider
      view.ylo = -half;
      view.yhi = half;
    }

    function setYFromTransformed(ft) {
      if (!ft.length) { view.ylo = -1; view.yhi = 1; return; }
      const ql = percentile(ft, 0.01), qh = percentile(ft, 0.99);
      const pad = 0.10 * (qh - ql);
      view.ylo = ql - pad;
      view.yhi = qh + pad;
    }


    const VIS_MIN_NM = 380, VIS_MAX_NM = 740;   // visible band
    function clampXToVisible(xlo, xhi) {
      let lo = Math.max(VIS_MIN_NM, xlo);
      let hi = Math.min(VIS_MAX_NM, xhi);
      if ((hi - lo) < MIN_X_SPAN) {
        const mid = Math.min(Math.max(0.5 * (xlo + xhi), VIS_MIN_NM + 0.5 * MIN_X_SPAN),
          VIS_MAX_NM - 0.5 * MIN_X_SPAN);
        lo = mid - 0.5 * MIN_X_SPAN; hi = mid + 0.5 * MIN_X_SPAN;
      }
      return [lo, hi];
    }

    function idxToLetters(i) { // 0 -> A, 25 -> Z, 26 -> AA ...
      let s = ""; i += 1;
      while (i > 0) {
        const r = (i - 1) % 26;
        s = String.fromCharCode(65 + r) + s;
        i = Math.floor((i - 1) / 26);
      }
      return s;
    }

    function transformFluxAuto(f) {
      if (!f?.length) return [];
      const m = median(f);
      const mad = median(f.map(v => Math.abs(v - m))) || 1;
      const s = 3 * mad;
      return f.map(v => Math.asinh((v - m) / s));
    }

    function transformFluxAbsBase(f) {
      const s0 = 3 * GLOBAL.mad;
      return f.map(v => Math.asinh((v - GLOBAL.med) / s0)); // centered at 0
    }


    function resize() {
      const dpr = window.devicePixelRatio || 1; canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr); ctx.setTransform(dpr, 0, 0, dpr, 0, 0); draw();
    }
    window.addEventListener('resize', resize);

    function setStatus(msg) { statusEl.textContent = msg; }

    function getPlotRect() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const L = 40, R = w - 10, T = 10, B = h - 30;
      return { L, R, T, B, W: R - L, H: B - T };
    }
    function hitScaleAt(x, y) {
      const { L, R, T, B } = getPlotRect();
      const y0 = (scaleY == null ? B : scaleY);
      return x >= L && x <= R && Math.abs(y - y0) <= 12;
    }

    function drawWavelengthScale(L, R, T, B, W) {
      // choose baseline (default at bottom axis B), and clamp within plot
      const baseY = scaleY == null ? B : Math.max(T + 12, Math.min(B, scaleY));
      scaleY = baseY;

      const spanNm = Math.max(1e-6, (view.xhi - view.xlo));
      const pxPerNm = W / spanNm;

      // major = 10 nm (always)
      const MAJOR = 10;

      // minor: prefer 1 nm if roomy, else 2 nm, else 5 nm (fallback none if too tight)
      const MIN_MINOR_PX = 10;
      let minor = null;
      if (pxPerNm * 1 >= MIN_MINOR_PX) minor = 1;
      else if (pxPerNm * 2 >= MIN_MINOR_PX) minor = 2;
      else if (pxPerNm * 5 >= MIN_MINOR_PX) minor = 5;

      // tertiary: only if it adds value
      const MIN_TERT_PX = 6;
      let tertiary = null;
      if (minor === 5 && pxPerNm * 1 >= MIN_TERT_PX) tertiary = 1;
      else if (minor === 1 && pxPerNm * 0.5 >= MIN_TERT_PX) tertiary = 0.5;

      const nm2x = nm => L + (nm - view.xlo) / spanNm * W;

      // baseline
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(L, baseY);
      ctx.lineTo(R, baseY);
      ctx.stroke();

      // tertiary ticks (smallest)
      if (tertiary) {
        ctx.strokeStyle = '#2a2a2a';
        ctx.lineWidth = 1;
        let n0 = Math.ceil(view.xlo / tertiary) * tertiary;
        for (let nm = n0; nm <= view.xhi; nm += tertiary) {
          const x = nm2x(nm);
          if (x < L - 1 || x > R + 1) continue;
          ctx.beginPath();
          ctx.moveTo(x, baseY);
          ctx.lineTo(x, baseY - 3);
          ctx.stroke();
        }
      }

      // minor ticks
      if (minor) {
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 1;
        let n0 = Math.ceil(view.xlo / minor) * minor;
        for (let nm = n0; nm <= view.xhi; nm += minor) {
          if (MAJOR && (nm % MAJOR === 0)) continue; // major will draw on top
          const x = nm2x(nm);
          if (x < L - 1 || x > R + 1) continue;
          ctx.beginPath();
          ctx.moveTo(x, baseY);
          ctx.lineTo(x, baseY - 6);
          ctx.stroke();
        }
      }

      // major ticks + labels (avoid label overlap if too tight)
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 1.25;
      ctx.fillStyle = '#bbb';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.font = '10px system-ui, sans-serif';

      let labelStep = MAJOR;            // try every 10 nm
      const MIN_LABEL_PX = 34;          // if tighter, relax labels but keep 10-nm big ticks
      if (pxPerNm * labelStep < MIN_LABEL_PX) labelStep = 20;
      if (pxPerNm * labelStep < MIN_LABEL_PX) labelStep = 50;
      if (pxPerNm * labelStep < MIN_LABEL_PX) labelStep = 100;

      let n0 = Math.ceil(view.xlo / MAJOR) * MAJOR;
      for (let nm = n0; nm <= view.xhi; nm += MAJOR) {
        const x = nm2x(nm);
        if (x < L - 1 || x > R + 1) continue;

        // tick
        ctx.beginPath();
        ctx.moveTo(x, baseY);
        ctx.lineTo(x, baseY - 9);
        ctx.stroke();

        // label (above tick)
        if (nm % labelStep === 0) {
          ctx.fillText(String(Math.round(nm)), x, baseY - 10);
        }
      }
    }


    // Stable 32-bit FNV-1a hash
    function fnv1a(str) {
      let h = 0x811c9dc5;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
      }
      return h >>> 0; // unsigned
    }

    // Change this to get a new (still-fixed) shuffle
    const SHUFFLE_SALT = 'galaxy-shuffle-v1';

    // Returns a permutation of indices in a deterministic pseudo-random order
    function stableShuffleOrder(arr) {
      const rows = arr.map((d, i) => {
        const key = String(d.id ?? d.name ?? i);
        const hash = fnv1a(SHUFFLE_SALT + '|' + key);
        return { i, hash };
      });
      rows.sort((a, b) => (a.hash - b.hash) || (a.i - b.i)); // tie-break by original index
      return rows.map(r => r.i);
    }

    function loadJSON(obj) {
      // apply deterministic shuffle
      const order = stableShuffleOrder(obj);
      data = order.map(i => obj[i]);

      objSel.innerHTML = '';
      data.forEach((d, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        const origName = (d.name && String(d.name).trim())
          ? d.name
          : (d.id ? d.id : `Obj ${i + 1}`);
        const galLabel = `Galaxy ${idxToLetters(i)}`; // A, B, C...
        opt.textContent = galLabel;
        opt.title = origName; // tooltip shows the real name
        objSel.appendChild(opt);
      });

      computeGlobalStats();
      current = 0; objSel.value = '0'; applySelection();

      if (document.getElementById('mapOverlay').style.display !== 'none') {
        buildMapPoints(); drawMap();
      }
    }

    function applySelection() {
      const d = data[current]; if (!d) return;

      const z = Number.isFinite(d.z) ? Number(d.z) : 0;
      zInput.value = z.toFixed(4);

      [view.xlo, view.xhi] = [VIS_MIN_NM, VIS_MAX_NM];

      if (yScaleSel.value === 'abs') {
        updateAbsYRange();                    // fixed Y window
      } else {
        const ft = transformFluxAuto(d.flux || []);
        const ql = percentile(ft, 0.01), qh = percentile(ft, 0.999);
        const span = qh - ql || 1;
        view.ylo = ql - 0.05 * span;
        view.yhi = qh + 0.25 * span;
      }

      // cutout + caption
      const img = document.getElementById('cutout');
      img.src = (d.image && d.image.path) ? d.image.path : "";
      const cutoutCaption = document.getElementById('cutoutCaption');
      cutoutCaption.textContent = (d.name && String(d.name).trim()) ? d.name : (d.id || '');

      drawLegend();
      draw();
    }

    function updateHover(e) {
      const rect = canvas.getBoundingClientRect();
      const pt = (e.touches && e.touches.length) ? e.touches[0] : e;
      const x = pt.clientX - rect.left;
      const y = pt.clientY - rect.top;

      const { L, R, T, B } = getPlotRect();
      hoverYpx = Math.max(T, Math.min(B, y));   // remember pointer Y (clamped)

      if (x >= L && x <= R && y >= T && y <= B) {
        const frac = (x - L) / Math.max(1, (R - L));
        hoverNm = view.xlo + frac * (view.xhi - view.xlo);
      } else {
        hoverNm = null; hoverYpx = null;
      }
    }


    // Baseline absolute transform (gain-independent)
    function transformFluxAbsBase(f) {
      const s0 = 3 * GLOBAL.mad;                // fixed softness
      return f.map(v => Math.asinh((v - GLOBAL.med) / s0));
    }

    const VIS_SPAN = VIS_MAX_NM - VIS_MIN_NM;
    function fitSpanToVisible(center, span) {
      span = Math.max(MIN_X_SPAN, Math.min(span, VIS_SPAN));
      let lo = center - 0.5 * span;
      let hi = center + 0.5 * span;
      if (lo < VIS_MIN_NM) { lo = VIS_MIN_NM; hi = lo + span; }
      if (hi > VIS_MAX_NM) { hi = VIS_MAX_NM; lo = hi - span; }
      return [lo, hi];
    }

    function wavelengthToRGB(nm) {
      // 380–780 nm -> [r,g,b] in 0–255
      let r = 0, g = 0, b = 0, a = 1, t = 0, wl = nm;
      if (wl < 380) wl = 380; if (wl > 780) wl = 780;
      if (wl < 440) { r = -(wl - 440) / (440 - 380); g = 0; b = 1; a = 0.3 + 0.7 * (wl - 380) / (60); }
      else if (wl < 490) { r = 0; g = (wl - 440) / (490 - 440); b = 1; }
      else if (wl < 510) { r = 0; g = 1; b = -(wl - 510) / (510 - 490); }
      else if (wl < 580) { r = (wl - 510) / (580 - 510); g = 1; b = 0; }
      else if (wl < 645) { r = 1; g = -(wl - 645) / (645 - 580); b = 0; }
      else { r = 1; g = 0; b = 0; a = 0.3 + 0.7 * (780 - wl) / (780 - 645); }
      const gamma = 0.8;
      r = Math.round(255 * Math.pow(r * a, gamma));
      g = Math.round(255 * Math.pow(g * a, gamma));
      b = Math.round(255 * Math.pow(b * a, gamma));
      return [r, g, b];
    }
    function rgb(r, g, b) { return `rgb(${r},${g},${b})`; }

    function percentile(a, p) {
      const b = [...a].sort((x, y) => x - y), n = b.length;
      if (n === 0) return 0;
      const i = (n - 1) * p, lo = Math.floor(i), hi = Math.ceil(i), h = i - lo;
      return (1 - h) * b[lo] + h * b[hi];
    }
    function median(a) { return percentile(a, 0.5); }
    function transformFlux(f) {
      // asinh works with negatives and compresses peaks
      const m = median(f);
      const mad = median(f.map(v => Math.abs(v - m))) || 1;
      const s = 3 * mad;                 // softness
      return f.map(v => Math.asinh((v - m) / s));
    }

    function x2px(x) { const w = canvas.clientWidth; return (x - view.xlo) / (view.xhi - view.xlo) * w; }
    function y2px(y) { const h = canvas.clientHeight; return h - (y - view.ylo) / (view.yhi - view.ylo) * h; }

    function drawLegend() {
      const z = Number(zInput.value) || 0;
      legend.textContent = REST_LINES.map(([lab, wlA]) => {
        const obsNm = ((modeSel.value === 'rest') ? wlA : wlA * (1 + z)) * A2NM;
        return `${lab}: ${obsNm.toFixed(1)} nm`;
      }).join('  |  ');
    }

    function draw() {
      const d = data[current]; if (!d) return;

      // clamp x-range to visible each draw
      if (typeof clampXToVisible === 'function') {
        const center = 0.5 * (view.xlo + view.xhi);
        const span = (view.xhi - view.xlo);
        [view.xlo, view.xhi] = fitSpanToVisible(center, span);
      }

      const w = canvas.clientWidth, h = canvas.clientHeight;
      const L = 40, R = w - 10, T = 10, B = h - 30, W = R - L, H = B - T;

      const z = Number(zInput.value) || 0;
      const mode = modeSel.value;

      const wlA = d.wavelength_A;
      const wlObsA = (mode === 'rest') ? wlA.map(w => w / (1 + z)) : wlA;
      const X = wlObsA.map(w => w * A2NM); // nm

      const g = parseFloat(gain.value) || 1;
      const fl = (yScaleSel.value === 'abs')
        ? transformFluxAbsBase(d.flux).map(v => v * g)   // slider acts here
        : transformFluxAuto(d.flux);


      // mappers over the plotting rect
      const x2 = x => L + (x - view.xlo) / (view.xhi - view.xlo) * W;
      const y2 = y => B - (y - view.ylo) / (view.yhi - view.ylo) * H;

      ctx.clearRect(0, 0, w, h);

      // axes
      ctx.lineWidth = 1; ctx.strokeStyle = '#333';
      ctx.beginPath(); ctx.moveTo(L, T); ctx.lineTo(L, B); ctx.lineTo(R, B); ctx.stroke();

      // wavelength scale (draggable baseline)
      drawWavelengthScale(L, R, T, B, W);

      // spectrum with wavelength-colored segments, clipped to visible band
      let pxPrev = null, pyPrev = null, nmPrev = null;
      const STEP = 1;
      for (let i = 0; i < X.length; i += STEP) {
        const nm = X[i];
        if (nm < view.xlo || nm > view.xhi) { pxPrev = pyPrev = nmPrev = null; continue; }
        const px = x2(nm);
        const py = y2(fl[i]);

        if (pxPrev !== null) {
          const nmMid = 0.5 * (nmPrev + nm);
          const [r, g, b] = wavelengthToRGB(nmMid);
          ctx.strokeStyle = rgb(r, g, b);
          ctx.beginPath(); ctx.moveTo(pxPrev, pyPrev); ctx.lineTo(px, py); ctx.stroke();
        }
        pxPrev = px; pyPrev = py; nmPrev = nm;
      }

      // rest lines + labels (symbol top, nm below)
      if (showLines.checked) {
        ctx.strokeStyle = '#444'; ctx.fillStyle = '#888';
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.font = '10px system-ui, sans-serif';
        for (const [lab, wlA0] of REST_LINES) {
          const xObsNm = ((mode === 'rest') ? wlA0 : wlA0 * (1 + z)) * A2NM;
          if (xObsNm < view.xlo || xObsNm > view.xhi) continue;
          const px = x2(xObsNm);
          ctx.beginPath(); ctx.moveTo(px, T + 2); ctx.lineTo(px, B); ctx.stroke();
          ctx.fillText(lab, px, T); ctx.fillText(`${xObsNm.toFixed(1)} nm`, px, T + 12);
        }
      }
      // labels
      ctx.fillStyle = '#aaa';
      ctx.textAlign = 'left'; ctx.fillText('Flux (arb.)', L - 32, T + 14);
      ctx.textAlign = 'right'; ctx.fillText(mode === 'rest' ? 'Rest wavelength (nm)' : 'Observed wavelength (nm)', R, B + 6);

      // --- hover measuring line ---
      if (hoverNm !== null && hoverNm >= view.xlo && hoverNm <= view.xhi) {
        const w = canvas.clientWidth, h = canvas.clientHeight;
        const L = 40, R = w - 10, T = 10, B = h - 30, W = R - L;
        const x2 = x => L + (x - view.xlo) / (view.xhi - view.xlo) * W;

        const px = x2(hoverNm);

        const [r, g, b] = wavelengthToRGB(hoverNm);
        const col = `rgb(${r},${g},${b})`;

        ctx.save();

        // colored vertical line with a soft glow
        ctx.strokeStyle = col;
        ctx.lineWidth = 1;
        ctx.shadowColor = `rgba(${r},${g},${b},0.6)`;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.moveTo(px, T + 2);
        ctx.lineTo(px, B);
        ctx.stroke();

        // wavelength label (outlined for readability), same color as the line


        // place label a bit above pointer, clamped inside plot
        const ly = Math.max(T + 12, Math.min(B - 12, (hoverYpx ?? B) - 10));

        // label above pointer
        const label = `${hoverNm.toFixed(1)} nm`;
        ctx.font = 'bold 14px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(0,0,0,0.65)';
        ctx.strokeText(label, px, ly);
        ctx.fillStyle = col;
        ctx.fillText(label, px, ly);
        ctx.restore();
      }
    }


    let draggingPlot = false, lastX = 0, lastY = 0;

    // MOUSE
    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (hitScaleAt(x, y)) {
        draggingScale = true;
        const { B } = getPlotRect();
        scaleGrabOffset = (scaleY == null ? B : scaleY) - y;
        e.preventDefault(); e.stopPropagation();
        return;
      }

      // start plot drag
      draggingPlot = true;
      lastX = e.clientX; lastY = e.clientY;
      updateHover(e);
    }, { passive: false });

    window.addEventListener('mousemove', e => {
      if (draggingScale) {
        const rect = canvas.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const { T, B } = getPlotRect();
        scaleY = Math.max(T + 12, Math.min(B, y + scaleGrabOffset));
        draw();
        return;
      }
      if (draggingPlot) {
        const dx = e.clientX - lastX, dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;

        const wx = view.xhi - view.xlo, wy = view.yhi - view.ylo;
        const fx = -dx / canvas.clientWidth, fy = dy / canvas.clientHeight;
        view.xlo += fx * wx; view.xhi += fx * wx;
        if (yScaleSel.value !== 'abs') { view.ylo += fy * wy; view.yhi += fy * wy; }
        draw();
      }
    });

    window.addEventListener('mouseup', () => { draggingPlot = false; draggingScale = false; });

    canvas.addEventListener('mousemove', e => { updateHover(e); draw(); }); // hover only
    canvas.addEventListener('mouseleave', () => { hoverNm = null; hoverYpx = null; draw(); });

    // TOUCH (scale dragging only; won’t interfere with plot handlers)
    canvas.addEventListener('touchstart', e => {
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      const x = t.clientX - rect.left, y = t.clientY - rect.top;
      if (!draggingScale) { updateHover(e); draw(); }
      if (hitScaleAt(x, y)) {
        draggingScale = true;
        const { B } = getPlotRect();
        scaleGrabOffset = (scaleY == null ? B : scaleY) - y;
        e.preventDefault(); e.stopPropagation();
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', e => {
      if (!draggingScale) { updateHover(e); draw(); }
      const rect = canvas.getBoundingClientRect();
      const t = e.touches[0];
      const y = t.clientY - rect.top;
      const { T, B } = getPlotRect();
      scaleY = Math.max(T + 12, Math.min(B, y + scaleGrabOffset));
      draw();
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', () => { draggingScale = false; hoverNm = null; hoverYpx = null; draw(); }, { passive: true });
    canvas.addEventListener('touchcancel', () => { draggingScale = false; hoverNm = null; hoverYpx = null; draw(); }, { passive: true });

    const MIN_X_SPAN = 5;      // nm
    const MIN_Y_SPAN = 0.02;   // display units after transform

    function zoom1D(lo, hi, center, factor) {
      const span = (hi - lo) * factor;
      return [center - 0.5 * span, center + 0.5 * span];
    }
    function clampSpan(lo, hi, minSpan) {
      if ((hi - lo) < minSpan) {
        const mid = 0.5 * (lo + hi);
        lo = mid - 0.5 * minSpan; hi = mid + 0.5 * minSpan;
      }
      return [lo, hi];
    }

    function wheelDir(e) {
      // +1 = scroll down, -1 = scroll up
      if (e.deltaY !== 0) return e.deltaY > 0 ? +1 : -1;
      if ('wheelDelta' in e && e.wheelDelta !== 0) return e.wheelDelta > 0 ? -1 : +1; // legacy inverted
      if ('detail' in e && e.detail !== 0) return e.detail > 0 ? +1 : -1;            // very old FF
      return 0;
    }

    canvas.addEventListener('wheel', e => {
      e.preventDefault();

      const w = canvas.clientWidth, h = canvas.clientHeight;
      const L = 40, R = w - 10, T = 10, B = h - 30, W = R - L, H = B - T;

      const mx = Math.min(1, Math.max(0, (e.clientX - canvas.getBoundingClientRect().left - L) / Math.max(1, W)));
      const my = Math.min(1, Math.max(0, (e.clientY - canvas.getBoundingClientRect().top - T) / Math.max(1, H)));

      const xmid = view.xlo + mx * (view.xhi - view.xlo);
      const ymid = view.yhi - my * (view.yhi - view.ylo);

      const dirY = wheelDir(e);              // -1 up, +1 down
      const dirX = Math.sign(e.deltaX || 0); // -1 left, +1 right
      const ZSTEP = 1.12;
      const factor = dirY > 0 ? ZSTEP : (dirY < 0 ? 1 / ZSTEP : 1);
      const panStep = 0.002;

      if (e.shiftKey) {
        if (yScaleSel.value !== 'abs') {
          const dyPan = dirY * panStep * (view.yhi - view.ylo);
          view.ylo += dyPan; view.yhi += dyPan;
        }
      }
      draw();
    }, { passive: false });

    yScaleSel.addEventListener('change', () => {
      if (yScaleSel.value === 'abs') updateAbsYRange();
      else applySelection();
      draw();
    });

    gain.addEventListener('input', () => {
      const g = parseFloat(gain.value) || 1;
      gainOut.textContent = '×' + g.toFixed(2);
      draw();
    });

    function setStatus(msg) { statusEl.textContent = msg; }

    objSel.addEventListener('change', () => { gain.value = 0.5; gainOut.textContent = "×0.50"; current = parseInt(objSel.value, 10); applySelection(); });
    modeSel.addEventListener('change', () => { drawLegend(); draw(); });
    applyZBtn.addEventListener('click', () => { drawLegend(); draw(); });
    document.getElementById('open').addEventListener('click', () => fileIn.click());
    fileIn.addEventListener('change', async () => {
      const f = fileIn.files[0]; if (!f) return;
      try {
        const obj = JSON.parse(await f.text()); if (!Array.isArray(obj)) throw new Error('JSON must be an array');
        loadJSON(obj); setStatus(`Loaded ${f.name} with ${obj.length} object(s)`);
      }
      catch (err) { setStatus('Invalid JSON: ' + err.message); }
    });

    fetch('spectra.json').then(r => {
      if (!r.ok) throw new Error('no spectra.json'); return r.json();
    }).then(obj => { loadJSON(obj); setStatus('Loaded spectra.json'); })
      .catch(() => setStatus('No local spectra.json. Use Open JSON.'));

    const showLines = document.getElementById('showLines');
    showLines.addEventListener('change', draw);

    resize();


    // ---- 3D Sky Map ----
    let showMapBtn, mapOverlay, mapCanvas, mapClose, mctx;
    const mapState = { rotX: 0, rotY: 0, scale: 1.2, dragging: false, lx: 0, ly: 0, centerRA: 0, centerDec: 0, pts: [], anim: null };

    window.addEventListener('DOMContentLoaded', () => {
      const showMapBtn = document.getElementById('showMap');
      const mapOverlay = document.getElementById('mapOverlay');
      const mapCanvas = document.getElementById('map3d');
      const mapClose = document.getElementById('mapClose');
      const mctx = mapCanvas.getContext('2d');

      const simDist = document.getElementById('simDist');

      // simple Hubble-law distance (low-z)
      const C_KMS = 299792.458, H0 = 70;  // km/s, km/s/Mpc
      const zToMpc = z => Math.max(0, (C_KMS / H0) * (Number(z) || 0));

      const mapState = {
        rotX: 0, rotY: 0,
        scale: 1.2,                 // zoom
        dragging: false, lx: 0, ly: 0,
        centerRA: 0, centerDec: 0,  // radians
        pts: [],                    // [{x,y,z,label,zval}]
        anim: null
      };

      // Helpers
      const DEG = Math.PI / 180;
      function rx(a, [x, y, z]) { const s = Math.sin(a), c = Math.cos(a); return [x, c * y - s * z, s * y + c * z]; }
      function ry(a, [x, y, z]) { const s = Math.sin(a), c = Math.cos(a); return [c * x + s * z, y, -s * x + c * z]; }
      function rz(a, [x, y, z]) { const s = Math.sin(a), c = Math.cos(a); return [c * x - s * y, s * x + c * y, z]; }
      function sphToVec(raDeg, decDeg) {
        const ra = raDeg * DEG, dec = decDeg * DEG;
        const cd = Math.cos(dec), sd = Math.sin(dec), cr = Math.cos(ra), sr = Math.sin(ra);
        return [cd * cr, cd * sr, sd];
      }
      function resizeMap() {
        const dpr = window.devicePixelRatio || 1;
        const rect = mapCanvas.getBoundingClientRect();
        mapCanvas.width = Math.max(1, Math.floor(rect.width * dpr));
        mapCanvas.height = Math.max(1, Math.floor(rect.height * dpr));
        mctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function buildMapPoints() {
        // center on currently selected object
        const d = data[current];
        let ra0 = 0, dec0 = 0;
        if (d && Number.isFinite(d.ra_deg) && Number.isFinite(d.dec_deg)) {
          ra0 = d.ra_deg * DEG;
          dec0 = d.dec_deg * DEG;
        }
        mapState.centerRA = ra0;
        mapState.centerDec = dec0;

        // distances for all (for normalization)
        const useDist = !!(simDist && simDist.checked);
        const dists = data.map(o => (o && Number.isFinite(o.z)) ? zToMpc(o.z) : 0);
        const maxD = dists.reduce((a, b) => Math.max(a, b), 0);

        mapState.pts = [];
        for (let i = 0; i < data.length; i++) {
          const o = data[i];
          if (!o || !Number.isFinite(o.ra_deg) || !Number.isFinite(o.dec_deg)) continue;

          const v = sphToVec(o.ra_deg, o.dec_deg); // unit vector
          // pre-rotate so selected is at front
          let p = rz(-ra0, v);
          p = rx(-dec0, p);

          const D = dists[i] || 0;
          // radius: flat shell when off, scaled 0.4..1.0 when on
          const r = (useDist && maxD > 0) ? (0.4 + 0.6 * (D / maxD)) : 1.0;

          mapState.pts.push({
            v: p,
            r,
            label: (o.name || o.id || 'obj'),
            zval: Number(o.z) || 0,
            isCurrent: (i === current)
          });
        }
      }

      function drawMap() {
        const w = mapCanvas.clientWidth, h = mapCanvas.clientHeight;
        mctx.clearRect(0, 0, w, h);

        // subtle background
        const g = mctx.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, Math.hypot(w, h) / 2);
        g.addColorStop(0, '#0b0b0b'); g.addColorStop(1, '#000');
        mctx.fillStyle = g; mctx.fillRect(0, 0, w, h);

        const pts2d = [];
        for (const p of mapState.pts) {
          // apply user rotation, then radial distance
          let q = ry(mapState.rotY, rx(mapState.rotX, p.v));
          q = [q[0] * p.r, q[1] * p.r, q[2] * p.r];

          // correct perspective (front => big)
          const camZ = 2.8;
          const z = camZ - q[2];
          if (z <= 0.05) continue;
          const f = mapState.scale * Math.min(w, h) * 0.42 / z;

          const x = w * 0.5 + q[0] * f;
          const y = h * 0.5 - q[1] * f;

          // color by z (blue→white→red), fade back hemisphere
          const zc = Math.max(-0.01, Math.min(0.05, p.zval));
          const t = (zc + 0.01) / 0.06;
          const rr = Math.round(200 * t + 55 * (1 - t));
          const bb = Math.round(200 * (1 - t) + 55 * t);
          const a = 0.35 + 0.65 * ((q[2] + 1) * 0.5); // front brighter

          pts2d.push({ x, y, z, r: rr, g: 220, b: bb, a, label: p.label, isCur: p.isCurrent });
        }

        // sphere rim (unit radius)
        mctx.strokeStyle = '#222'; mctx.lineWidth = 1;
        mctx.beginPath();
        mctx.arc(w / 2, h / 2, Math.min(w, h) * 0.42 * mapState.scale, 0, Math.PI * 2);
        mctx.stroke();

        // back-to-front
        pts2d.sort((A, B) => B.z - A.z);

        // draw normals
        for (const p of pts2d) {
          if (p.isCur) continue;
          mctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${p.a.toFixed(3)})`;
          mctx.beginPath(); mctx.arc(p.x, p.y, 3, 0, Math.PI * 2); mctx.fill();
        }

        // highlight current
        const cur = pts2d.find(p => p.isCur);
        if (cur) {
          mctx.save();
          mctx.shadowColor = 'rgba(0,0,0,0.7)'; mctx.shadowBlur = 6;
          mctx.fillStyle = '#fff';
          mctx.beginPath(); mctx.arc(cur.x, cur.y, 5, 0, Math.PI * 2); mctx.fill();
          mctx.lineWidth = 2; mctx.strokeStyle = 'rgba(0,0,0,0.6)'; mctx.stroke();
          mctx.shadowColor = 'transparent'; mctx.shadowBlur = 0;
          mctx.font = '600 13px system-ui, sans-serif';
          mctx.textAlign = 'left'; mctx.textBaseline = 'middle';
          mctx.fillStyle = '#fff';
          const label = (data[current]?.name || data[current]?.id || 'current');
          mctx.fillText(label, cur.x + 10, cur.y);
          mctx.restore();
        }

        // crosshair
        mctx.strokeStyle = 'rgba(255,255,255,.08)';
        mctx.beginPath();
        mctx.moveTo(w / 2 - 10, h / 2); mctx.lineTo(w / 2 + 10, h / 2);
        mctx.moveTo(w / 2, h / 2 - 10); mctx.lineTo(w / 2, h / 2 + 10);
        mctx.stroke();

        // --- Milky Way center marker ---
        const cx = w * 0.5, cy = h * 0.5;
        mctx.save();
        // dot with subtle outline
        mctx.fillStyle = '#ffd65a';           // warm gold to stand out
        mctx.strokeStyle = 'rgba(0,0,0,.6)';
        mctx.lineWidth = 2;
        mctx.beginPath(); mctx.arc(cx, cy, 4, 0, Math.PI * 2); mctx.fill(); mctx.stroke();

        // label next to the dot (outlined for readability)
        const label = 'Milky Way';
        mctx.font = 'bold 12px system-ui, sans-serif';
        mctx.textAlign = 'left';
        mctx.textBaseline = 'middle';
        mctx.strokeStyle = 'rgba(0,0,0,.7)';
        mctx.lineWidth = 3;
        mctx.strokeText(label, cx + 8, cy);
        mctx.fillStyle = '#fff';
        mctx.fillText(label, cx + 8, cy);
        mctx.restore();
      }


      function openMap() {
        mapOverlay.style.display = 'block';          // show first
        requestAnimationFrame(() => {                // wait 1 frame so layout exists
          resizeMap();                               // now clientWidth/Height are > 0
          buildMapPoints();
          drawMap();
        });
      }
      function closeMap() {
        mapOverlay.style.display = 'none';
        if (mapState.anim) cancelAnimationFrame(mapState.anim);
      }



      // events
      // ---- TOUCH support: one finger rotate, two fingers pinch-zoom ----
      let touchMode = 'none';
      let pinchPrevDist = 0;

      function touchDist(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.hypot(dx, dy);
      }

      mapCanvas.addEventListener('touchstart', e => {
        if (e.touches.length === 1) {
          // rotate
          touchMode = 'rotate';
          mapState.dragging = true;
          mapState.lx = e.touches[0].clientX;
          mapState.ly = e.touches[0].clientY;
        } else if (e.touches.length >= 2) {
          // pinch
          touchMode = 'pinch';
          mapState.dragging = false;
          pinchPrevDist = touchDist(e.touches);
        }
        e.preventDefault();
      }, { passive: false });

      mapCanvas.addEventListener('touchmove', e => {
        if (touchMode === 'rotate' && e.touches.length === 1) {
          const t = e.touches[0];
          const dx = t.clientX - mapState.lx;
          const dy = t.clientY - mapState.ly;
          mapState.lx = t.clientX;
          mapState.ly = t.clientY;

          mapState.rotY += dx * 0.005;
          mapState.rotX += dy * 0.005;
          mapState.rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mapState.rotX));
          drawMap();
        } else if (e.touches.length >= 2) {
          // pinch zoom
          const d = touchDist(e.touches);
          if (pinchPrevDist > 0) {
            const factor = d / pinchPrevDist;          // >1 zoom in, <1 zoom out
            mapState.scale *= factor;
            mapState.scale = Math.max(0.6, Math.min(3.0, mapState.scale));
            drawMap();
          }
          pinchPrevDist = d;
        }
        e.preventDefault();
      }, { passive: false });

      mapCanvas.addEventListener('touchend', e => {
        if (e.touches.length === 0) {
          touchMode = 'none';
          mapState.dragging = false;
          pinchPrevDist = 0;
        } else if (e.touches.length === 1) {
          // fall back to rotate with remaining finger
          touchMode = 'rotate';
          mapState.dragging = true;
          mapState.lx = e.touches[0].clientX;
          mapState.ly = e.touches[0].clientY;
          pinchPrevDist = 0;
        }
        e.preventDefault();
      }, { passive: false });

      mapCanvas.addEventListener('touchcancel', () => {
        touchMode = 'none';
        mapState.dragging = false;
        pinchPrevDist = 0;
      }, { passive: false });

      showMapBtn.addEventListener('click', openMap);
      mapClose.addEventListener('click', closeMap);
      simDist.addEventListener('change', () => {
        if (mapOverlay.style.display !== 'none') { buildMapPoints(); drawMap(); }
      });
      objSel.addEventListener('change', () => {
        if (mapOverlay.style.display !== 'none') { buildMapPoints(); drawMap(); }
      });
      window.addEventListener('resize', () => { if (mapOverlay.style.display !== 'none') { resizeMap(); drawMap(); } });
      document.addEventListener('keydown', e => { if (e.key === 'Escape' && mapOverlay.style.display !== 'none') closeMap(); });

      mapCanvas.addEventListener('mousedown', e => { mapState.dragging = true; mapState.lx = e.clientX; mapState.ly = e.clientY; });
      window.addEventListener('mouseup', () => { mapState.dragging = false; });
      window.addEventListener('mousemove', e => {
        if (!mapState.dragging) return;
        const dx = e.clientX - mapState.lx, dy = e.clientY - mapState.ly;
        mapState.lx = e.clientX; mapState.ly = e.clientY;
        // adjust sensitivity; clamp X rotation to avoid flipping too fast
        mapState.rotY += dx * 0.005;
        mapState.rotX += dy * 0.005;
        mapState.rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mapState.rotX));
        drawMap();
      });
      mapCanvas.addEventListener('wheel', e => {
        e.preventDefault();
        const dir = e.deltaY > 0 ? +1 : -1;       // down=out, up=in
        const zstep = 1.1;
        mapState.scale *= (dir > 0 ? 1 / zstep : zstep);
        mapState.scale = Math.max(0.6, Math.min(3.0, mapState.scale));
        drawMap();
      }, { passive: false });
    });

  </script>
  <div id="cutoutWrap">
    <img id="cutout" alt="cutout">
    <div id="cutoutCaption" aria-live="polite"></div>
  </div>
  <div id="mapOverlay" style="display:none">
    <canvas id="map3d"></canvas>
    <div id="mapControls">
      <label><input id="simDist" type="checkbox"> Simulate distance</label>
    </div>
    <button id="mapClose" aria-label="Close Map">✕</button>
  </div>
</body>

</html>