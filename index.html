<!doctype html>
<html lang='en'>

<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <title>Galaxy Spectra Redshift Viewer</title>
  <style>
    :root {
      color-scheme: dark light;
      --sideW: 320px;
      --slideMs: 240ms;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      overscroll-behavior: none;
    }

    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #0b0b0b;
      color: #e5e5e5;
    }

    /* Top toolbar */
    header.toolbar {
      position: sticky;
      top: 0;
      z-index: 5;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      background: #111;
      border-bottom: 1px solid #222;
    }

    header .group {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    header .title {
      font: 700 16px/1 system-ui, sans-serif;
      margin-right: 6px;
      color: #ddd;
    }

    select,
    input,
    button {
      background: #181818;
      color: #ddd;
      border: 1px solid #333;
      border-radius: 8px;
      padding: 6px 10px;
    }

    select.lg,
    button.lg {
      padding: 8px 12px;
      font-weight: 600;
    }

    #status {
      margin-left: auto;
    }

    /* Layout */
    main.layout {
      display: grid;
      gap: 12px;
      padding: 12px;
      grid-template-columns: 1fr var(--sideW);
      /* side width comes from the track */
      transition: grid-template-columns var(--slideMs) ease;
    }

    body.panel-collapsed main.layout {
      grid-template-columns: 1fr 0;
      /* collapse the track */
    }


    #plotArea {
      position: relative;
      min-height: 60vh;
    }

    #canvas {
      display: block;
      width: 100%;
      height: calc(100vh - 220px);
      background: #0a0a0a;
      touch-action: none;
      border: 1px solid #222;
      border-radius: 10px;
    }

    /* Readable, mobile-friendly legend bar over the plot */
    #legendBar {
      position: absolute;
      left: 50%;
      top: 8px;
      transform: translateX(-50%);
      max-width: min(900px, 92%);
      padding: 6px 10px;
      background: rgba(0, 0, 0, .55);
      backdrop-filter: blur(4px);
      border: 1px solid #333;
      border-radius: 999px;
      overflow: auto;
      white-space: nowrap;
    }

    #legend {
      font-size: 13px;
      color: #e5e5e5;
    }

    /* Right panel (image + simple controls) */
    aside#sidePanel {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    #cutoutWrap {
      position: sticky;
      top: 12px;
      width: 100%;
      height: 260px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #000;
      overflow: hidden;
    }

    #cutout {
      width: 100%;
      height: 100%;
      object-fit: contain;
      opacity: .95;
      pointer-events: none;
    }

    #cutoutCaption {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 6px 10px;
      font: 600 12px/1.2 system-ui, sans-serif;
      color: #eee;
      text-align: right;
      background: linear-gradient(to top, rgba(0, 0, 0, .55), rgba(0, 0, 0, 0));
      text-shadow: 0 1px 2px rgba(0, 0, 0, .7);
    }

    .card {
      border: 1px solid #333;
      border-radius: 12px;
      background: #141414;
      padding: 10px;
    }

    .card h3 {
      margin: 0 0 8px;
      font: 600 13px/1 system-ui, sans-serif;
      color: #bbb;
    }

    /* “More” menu for teacher/admin items */
    details.more {
      margin-left: auto;
    }

    details.more summary {
      list-style: none;
      cursor: pointer;
      padding: 6px 10px;
      border: 1px solid #333;
      border-radius: 8px;
      background: #181818;
    }

    details.more[open] summary {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    }

    .moreMenu {
      border: 1px solid #333;
      border-top: none;
      background: #141414;
      padding: 10px;
      border-radius: 0 0 8px 8px;
      display: grid;
      gap: 8px;
      grid-template-columns: 1fr auto;
    }

    .moreMenu label {
      font-size: 12px;
      color: #aaa;
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .help {
      font-size: 12px;
      color: #888;
    }

    /* Footer gone — legend moved up. Keep footer shell if you need attribution later */
    footer {
      display: none;
    }

    #mapOverlay {
      position: fixed;
      inset: 0;
      z-index: 1000;
      background: rgba(0, 0, 0, .88);
      display: none;
    }

    #map3d {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      cursor: grab;
      touch-action: none;
    }

    #mapClose {
      position: absolute;
      top: 12px;
      right: 12px;
      z-index: 2;
    }

    #mapControls {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 2;
    }

    #map3d:active {
      cursor: grabbing;
    }

    aside#sidePanel {
      min-width: 0;
      /* allow shrinking to 0 */
      overflow: hidden;
      /* clip while sliding */
      border-left: 1px solid #222;
      border-radius: 10px;
    }

    body.panel-collapsed aside#sidePanel {
      width: 0;
    }

    /* hamburger button style */
    .icon-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      cursor: pointer;
      border: 1px solid #333;
      border-radius: 8px;
      background: #181818;
      color: #ddd;
    }

    .icon-btn:active {
      transform: translateY(1px);
    }

    /* Responsive */
    @media (max-width: 900px) {
      main.layout {
        grid-template-columns: 1fr;
      }

      aside#sidePanel {
        max-height: 520px;
        transition: max-height var(--slideMs) ease;
      }

      body.panel-collapsed aside#sidePanel {
        max-height: 0;
      }
    }

    header.toolbar {
      flex-wrap: wrap;
      /* allow wrapping */
      row-gap: 10px;
      /* tidy vertical spacing */
    }

    /* Title on its own row when cramped */
    @media (max-width: 900px) {
      header.toolbar .title {
        flex: 1 1 100%;
        order: 0;
      }

      /* Make each control block responsive, two per row by default */
      header.toolbar .group,
      header.toolbar>label.group,
      header.toolbar button,
      header.toolbar details.more {
        flex: 1 1 220px;
        /* grows, wraps at ~220px */
        min-width: 0;
        /* prevent overflow */
      }

      /* Stack label above control for readability */
      header.toolbar .group label {
        display: block;
        margin: 0 0 4px;
        font-size: 11px;
        color: #aaa;
      }

      /* Inputs span full width inside their block */
      header.toolbar select,
      header.toolbar input[type="number"],
      header.toolbar input[type="range"],
      header.toolbar button {
        width: 100%;
      }

      /* Compact control padding on small screens */
      header.toolbar select,
      header.toolbar input,
      header.toolbar button {
        padding: 6px 8px;
      }

      /* Keep toggles and the map button compact */
      #showMap,
      #togglePanel.icon-btn {
        flex: 0 0 auto;
      }

      /* "More" becomes a full-width drawer row */
      details.more {
        order: 99;
        margin-left: 0;
        flex: 1 1 100%;
      }

      /* Reduce crowding: hide live gain badge on small screens */
      #gainOut {
        display: none;
      }
    }

    /* Extra-small phones: tighter grid */
    @media (max-width: 520px) {

      header.toolbar .group,
      header.toolbar>label.group,
      header.toolbar button {
        flex: 1 1 48%;
        /* two columns */
      }

      /* Let very small items keep their natural size */
      #showMap,
      #togglePanel.icon-btn {
        flex: 0 0 auto;
      }

      /* Slightly smaller control chrome */
      header.toolbar select,
      header.toolbar input,
      header.toolbar button {
        border-radius: 6px;
        padding: 5px 7px;
        font-size: 14px;
      }
    }

    /* Prevent long option text from blowing up layout */
    header.toolbar select {
      max-width: 100%;
      text-overflow: ellipsis;
    }

    /* Checkbox rows look like other groups */
    header.toolbar>label.group {
      align-items: center;
      gap: 6px;
    }
  </style>

  <header class="toolbar">
    <div class="title">Galaxy Spectra Viewer</div>

    <div class="group">
      <label for="obj" style="font-size:12px;color:#aaa">Galaxy</label>
      <select id="obj" class="lg"></select>
    </div>

    <div class="group">
      <label for="mode" style="font-size:12px;color:#aaa">Frame</label>
      <select id="mode">
        <option value="observed">Observed</option>
        <option value="rest">Rest-frame</option>
      </select>
    </div>

    <div class="group">
      <label for="yscale" style="font-size:12px;color:#aaa">Y-scale</label>
      <select id="yscale">
        <option value="auto">Auto</option>
        <option value="abs" selected>Absolute</option>
      </select>
    </div>

    <div class="group">
      <label for="gain" style="font-size:12px;color:#aaa">Flux</label>
      <input id="gain" type="range" min="0.01" max="2" step="0.01" value="0.50">
      <output id="gainOut" class="pill">×0.50</output>
    </div>

    <label class="group" style="gap:6px;"><input id="showLines" type="checkbox"> Show Element Guidelines</label>

    <button id="showMap">Sky map</button>
    <label class="group" style="gap:6px;">
      <input id="spectro" type="checkbox"> Spectroscope view
    </label>
    <details class="more">
      <summary>More</summary>
      <div class="moreMenu">
        <label>z <input id="z" type="number" step="any" inputmode="decimal" value="0" style="width:130px"></label>
        <button id="applyZ">Apply z</button>
        <span class="help">Teacher tools:</span>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="open">Load JSON…</button>
          <span class="pill" id="status">No file loaded</span>
        </div>
      </div>
    </details>
    <button id="togglePanel" class="icon-btn" aria-label="Toggle side panel" aria-expanded="true" aria-pressed="false"
      title="Toggle side panel">☰</button>
  </header>

  <main class="layout">
    <section id="plotArea">
      <div id="legendBar">
        <div id="legend"></div>
      </div>
      <canvas id="canvas"></canvas>
    </section>

    <aside id="sidePanel">
      <div id="cutoutWrap">
        <img id="cutout" alt="Galaxy cutout">
        <div id="cutoutCaption" aria-live="polite"></div>
      </div>

      <div class="card">
        <h3>Viewing tips</h3>
        <ul style="margin:0 0 0 16px; padding:0; color:#9aa;">
          <li>Drag the wavelength scale to move it closer to the plot.</li>
          <li>Scroll (or two-finger swipe) to pan vertically.</li>
          <li>Tap/hover to read wavelength; vertical color line matches spectrum color.</li>
        </ul>
      </div>
    </aside>
  </main>

  <footer></footer>
  <input type='file' id='file' accept='.json' style='display:none'>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const objSel = document.getElementById('obj');
    const modeSel = document.getElementById('mode');
    const zInput = document.getElementById('z');
    const applyZBtn = document.getElementById('applyZ');
    const statusEl = document.getElementById('status');
    const openBtn = document.getElementById('open');
    const fileIn = document.getElementById('file');
    const legend = document.getElementById('legend');
    let hoverNm = null, hoverYpx = null;  // current hover wavelength in nm (or null)

    // ---- wavelength scale (draggable) ----
    let scaleY = null;           // pixel Y of the scale baseline; null ⇒ default at B
    let draggingScale = false;
    let scaleGrabOffset = 0;     // mouse Y offset when grabbing the scale
    let scaleHover = false;   // mouse is over the draggable scale?
    let twoTouchActive = false;
    let twoTouchPrevY = null;
    let pinchPrevDist = 0;
    let pinchAnchorNm = null;
    let currentZ = 0;

    // --- X-pan inertia ---
    const XIN = { vx: 0, raf: 0, last: 0 };
    const X_FRICTION = 0.92;          // per 16.7 ms
    const X_MIN_V = 1e-4;             // nm/ms threshold
    const X_GAIN = 0.06;              // maps wheel deltaX to nm/ms

    const REST_LINES = [
      //["[O II]", 3727.0],
      ["Hδ", 4101.74],
      ["Hγ", 4340.47],
      ["Hβ", 4861.33],
      //["[O III]", 4958.91],
      //["[O III]", 5006.84],
      ["Mg b", 5175.0],
      ["Na D\u2081", 5889.90],
      ["Na D\u2082", 5895.90],
      ["Hα", 6562.80],
      //["[N II]", 6583.45],
      //["[S II]", 6716.44],
      //["[S II]", 6730.82],
      //["Ca K", 3933.66],
      //["Ca H", 3968.47],
    ];
    const A2NM = 0.1;

    let data = []; let view = { xlo: 3500, xhi: 9000, ylo: -1, yhi: 5 }; let current = 0;

    const yScaleSel = document.getElementById('yscale');
    const gain = document.getElementById('gain');
    const gainOut = document.getElementById('gainOut');

    // --- ABS envelope (fixed y-window, center-locked) ---
    let GLOBAL = { med: 0, mad: 1, qlo: 0, qhi: 0 };
    let ABS_BASE_R = 1;               // half-height in transformed units
    const ABS_PAD_FRAC = 0.20;

    // --- Reset overlay button ---
    let resetBtnVisible = false;
    let resetBtnRect = null; // {x,y,w,h} in CSS px

    function showResetButton() { resetBtnVisible = true; }
    function hideResetButton() { resetBtnVisible = false; resetBtnRect = null; }

    function stopXInertia() {
      if (XIN.raf) cancelAnimationFrame(XIN.raf);
      XIN.vx = 0; XIN.raf = 0; XIN.last = 0;
    }
    function stepXInertia(t) {
      if (!XIN.raf) return;
      const now = t || performance.now();
      const dt = Math.max(0, Math.min(32, now - (XIN.last || now)));
      XIN.last = now;

      // move
      const dxNm = XIN.vx * dt;
      view.xlo += dxNm; view.xhi += dxNm;

      // hard clamp and kill velocity at edges
      if (view.xlo < VIS_MIN_NM) {
        const s = VIS_MIN_NM - view.xlo;
        view.xlo += s; view.xhi += s;
        XIN.vx = 0;
      }
      if (view.xhi > VIS_MAX_NM) {
        const s = view.xhi - VIS_MAX_NM;
        view.xlo -= s; view.xhi -= s;
        XIN.vx = 0;
      }

      // decay
      const decay = Math.pow(X_FRICTION, dt / 16.7);
      XIN.vx *= decay;

      draw();
      if (Math.abs(XIN.vx) < X_MIN_V) { stopXInertia(); return; }
      XIN.raf = requestAnimationFrame(stepXInertia);
    }

    function startXInertia(vx0) {
      XIN.vx = vx0;
      if (!XIN.raf) {
        XIN.last = performance.now();
        XIN.raf = requestAnimationFrame(stepXInertia);
      }
    }

    // --- vertical pan bounds/slow ---
    const Y_MARGIN = 0.02;          // padding in display units
    const Y_FINGER_SLOW = 0.25;     // touch two-finger
    const Y_MOUSE_SLOW = 0.25;     // mouse drag
    const Y_WHEEL_SLOW = 0.12;     // wheel

    function currentContentBounds() {
      const d = data[current]; if (!d) return { ymin: -1, ymax: 1 };
      const g = parseFloat(gain.value) || 1;
      const ft = (yScaleSel.value === 'abs')
        ? transformFluxAbsBase(d.flux).map(v => v * g)
        : transformFluxAuto(d.flux);
      let ymin = Infinity, ymax = -Infinity;
      for (const v of ft) { if (v < ymin) ymin = v; if (v > ymax) ymax = v; }
      return {
        ymin: Number.isFinite(ymin) ? ymin : -1,
        ymax: Number.isFinite(ymax) ? ymax : 1
      };
    }

    function clampYPan(rawShift) {
      const { ymin, ymax } = currentContentBounds();
      const smin = (ymax - Y_MARGIN) - view.yhi; // top cannot go below max
      const smax = (ymin + Y_MARGIN) - view.ylo; // bottom cannot go above min
      return Math.max(smin, Math.min(smax, rawShift));
    }

    // Collision-aware row layout for vertical line labels
    function layoutLineRows(items, gapPx, maxRows) {
      // items: [{px, ...}] sorted by px asc
      const lastX = Array(maxRows).fill(-Infinity);
      for (const it of items) {
        let r = 0;
        while (r < maxRows && (it.px - lastX[r]) < gapPx) r++;
        if (r >= maxRows) r = maxRows - 1;   // clamp to last row if crowded
        it.row = r;
        lastX[r] = it.px;
      }
    }

    function resetDisplay() {
      stopXInertia();
      // X: full visible band
      view.xlo = VIS_MIN_NM; view.xhi = VIS_MAX_NM;
      // Y: mode-dependent
      if (yScaleSel.value === 'abs') updateAbsYRange();
      else {
        const d = data[current]; const ft = transformFluxAuto(d?.flux || []);
        setYFromTransformed(ft);
      }
      scaleY = null; // scale baseline back to axis
      hideResetButton();
      draw();
    }

    function computeGlobalStats() {
      const all = data.flatMap(d => d.flux || []);
      if (!all.length) { GLOBAL = { med: 0, mad: 1, qlo: -1, qhi: 1 }; ABS_BASE_R = 1; return; }
      const m = median(all);
      const mad = median(all.map(v => Math.abs(v - m))) || 1;
      const qlo = percentile(all, 0.001);
      const qhi = percentile(all, 0.999);
      GLOBAL = { med: m, mad, qlo, qhi };
      // compute fixed y envelope from global extremes in asinh space
      const s0 = 3 * GLOBAL.mad;
      const y0lo = Math.asinh((GLOBAL.qlo - GLOBAL.med) / s0);
      const y0hi = Math.asinh((GLOBAL.qhi - GLOBAL.med) / s0);
      ABS_BASE_R = Math.max(Math.abs(y0lo), Math.abs(y0hi)) || 1;
    }

    function updateAbsYRange() {
      const half = ABS_BASE_R * (1 + ABS_PAD_FRAC);  // fixed, independent of slider
      view.ylo = -half;
      view.yhi = half;
    }

    function setYFromTransformed(ft) {
      if (!ft.length) { view.ylo = -1; view.yhi = 1; return; }
      const ql = percentile(ft, 0.01), qh = percentile(ft, 0.99);
      const pad = 0.10 * (qh - ql);
      view.ylo = ql - pad;
      view.yhi = qh + pad;
    }


    const VIS_MIN_NM = 380, VIS_MAX_NM = 740;   // visible band
    function clampXToVisible(xlo, xhi) {
      let lo = Math.max(VIS_MIN_NM, xlo);
      let hi = Math.min(VIS_MAX_NM, xhi);
      if ((hi - lo) < MIN_X_SPAN) {
        const mid = Math.min(Math.max(0.5 * (xlo + xhi), VIS_MIN_NM + 0.5 * MIN_X_SPAN),
          VIS_MAX_NM - 0.5 * MIN_X_SPAN);
        lo = mid - 0.5 * MIN_X_SPAN; hi = mid + 0.5 * MIN_X_SPAN;
      }
      return [lo, hi];
    }

    function idxToLetters(i) { // 0 -> A, 25 -> Z, 26 -> AA ...
      let s = ""; i += 1;
      while (i > 0) {
        const r = (i - 1) % 26;
        s = String.fromCharCode(65 + r) + s;
        i = Math.floor((i - 1) / 26);
      }
      return s;
    }

    function transformFluxAuto(f) {
      if (!f?.length) return [];
      const m = median(f);
      const mad = median(f.map(v => Math.abs(v - m))) || 1;
      const s = 3 * mad;
      return f.map(v => Math.asinh((v - m) / s));
    }

    function resize() {
      const dpr = window.devicePixelRatio || 1; canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr); ctx.setTransform(dpr, 0, 0, dpr, 0, 0); draw();
    }
    window.addEventListener('resize', resize);

    function getPlotRect() {
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const L = 40, R = w - 10, T = 10, B = h - 30;
      return { L, R, T, B, W: R - L, H: B - T };
    }
    function hitScaleAt(x, y) {
      const { L, R, T, B } = getPlotRect();
      const y0 = (scaleY == null ? B : scaleY);
      return x >= L && x <= R && Math.abs(y - y0) <= 12;
    }

    function updateScaleHover(e) {
      const rect = canvas.getBoundingClientRect();
      const pt = e.touches?.[0] ?? e;
      const x = pt.clientX - rect.left;
      const y = pt.clientY - rect.top;

      const was = scaleHover;
      scaleHover = hitScaleAt(x, y);

      // cursor: hand over scale, grabbing while dragging
      canvas.style.cursor = draggingScale ? 'grabbing' : (scaleHover ? 'grab' : 'auto');

      if (scaleHover !== was) draw(); // re-draw to toggle glow
    }

    // Helper: where can labels start (just below legend if it overlaps canvas)
    function legendLabelTop(T = 10) {
      const bar = document.getElementById('legendBar');
      if (!bar) return T;
      const barRect = bar.getBoundingClientRect();
      const canRect = canvas.getBoundingClientRect();
      // If no overlap, keep default top
      const overlaps =
        !(barRect.bottom < canRect.top ||
          barRect.top > canRect.bottom ||
          barRect.right < canRect.left ||
          barRect.left > canRect.right);
      if (!overlaps) return T;
      const gap = 6; // px padding under the legend
      return Math.max(T, Math.round(barRect.bottom - canRect.top + gap));
    }

    // Air ↔ vacuum index (Edlén/Peck; standard in SDSS/Morton)
    function nAir(lamA) {
      const s2 = (1e4 / lamA) ** 2;         // σ^2 in µm^-2
      return 1 + 1e-8 * (6432.8 + 2949810 / (146.0 - s2) + 25540 / (41.0 - s2));
    }
    function airToVacAA(lamAir) {
      let lam = lamAir;
      for (let i = 0; i < 2; i++) lam = lamAir * nAir(lam);
      return lam;
    }

    function getScaleTiers(pxPerNm) {
      // thresholds tuned for readability on HiDPI and standard screens
      if (pxPerNm >= 15) return { major: 2, minor: 1, tert: 0.1 }; // case 4
      if (pxPerNm >= 5) return { major: 5, minor: 1, tert: 0.5 }; // case 3
      if (pxPerNm >= 2) return { major: 10, minor: 2, tert: 1 }; // case 2
      return { major: 10, minor: 5, tert: 1 }; // case 1 (zoomed out)
    }

    function drawWavelengthScale(L, R, T, B, W) {
      // baseline
      const baseY = scaleY == null ? B : Math.max(T + 12, Math.min(B, scaleY));
      scaleY = baseY;

      const spanNm = Math.max(1e-6, (view.xhi - view.xlo));
      const pxPerNm = W / spanNm;
      const { major: MAJOR, minor: MINOR, tert: TERT } = getScaleTiers(pxPerNm);
      const fine = !!TERT && TERT <= 0.1;     // 0.1 nm tier
      const EPS = 1e-6;

      const nm2x = nm => L + (nm - view.xlo) / spanNm * W;

      // baseline (brighter + hover glow)
      const hovered = scaleHover || draggingScale;
      ctx.save();
      ctx.lineWidth = hovered ? 1.8 : 1.2;
      ctx.strokeStyle = hovered ? '#9ecbff' : '#6a86a5';
      if (hovered) { ctx.shadowColor = 'rgba(158,203,255,0.9)'; ctx.shadowBlur = 10; }
      ctx.beginPath(); ctx.moveTo(L, baseY); ctx.lineTo(R, baseY); ctx.stroke();
      ctx.restore();

      // subtle grid on majors (integers in fine mode)
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.lineWidth = 1;
      const gridStep = fine ? 1 : MAJOR;
      let g0 = Math.ceil(view.xlo / gridStep) * gridStep;
      for (let nm = g0; nm <= view.xhi + EPS; nm += gridStep) {
        const x = nm2x(nm);
        ctx.beginPath(); ctx.moveTo(x, baseY - 18); ctx.lineTo(x, baseY); ctx.stroke();
      }
      ctx.restore();

      // third-tier ticks
      if (TERT) {
        ctx.strokeStyle = '#5f6670';
        ctx.lineWidth = 1;
        let n0 = Math.ceil(view.xlo / TERT) * TERT;
        for (let nm = n0; nm <= view.xhi + EPS; nm += TERT) {
          if (fine) { if (Math.abs(nm - Math.round(nm)) < 1e-6) continue; } // skip integers
          else {
            if (Math.abs(nm / MINOR - Math.round(nm / MINOR)) < 1e-6) continue;
            if (Math.abs(nm / MAJOR - Math.round(nm / MAJOR)) < 1e-6) continue;
          }
          const x = nm2x(nm);
          ctx.beginPath(); ctx.moveTo(x, baseY); ctx.lineTo(x, baseY - 3); ctx.stroke();
        }
      }

      // minor ticks (suppressed in fine mode)
      if (!fine && MINOR) {
        ctx.strokeStyle = '#556270';
        ctx.lineWidth = 1;
        let n0 = Math.ceil(view.xlo / MINOR) * MINOR;
        for (let nm = n0; nm <= view.xhi + EPS; nm += MINOR) {
          if (Math.abs(nm / MAJOR - Math.round(nm / MAJOR)) < 1e-6) continue;
          const x = nm2x(nm);
          ctx.beginPath(); ctx.moveTo(x, baseY); ctx.lineTo(x, baseY - 6); ctx.stroke();
        }
      }

      // major ticks
      ctx.strokeStyle = '#a9b7c6';
      ctx.lineWidth = 1.6;
      if (fine) {
        const i0 = Math.ceil(view.xlo), i1 = Math.floor(view.xhi);
        for (let i = i0; i <= i1; i++) {
          const x = nm2x(i);
          ctx.beginPath(); ctx.moveTo(x, baseY); ctx.lineTo(x, baseY - 10); ctx.stroke();
        }
      } else {
        let m0 = Math.ceil(view.xlo / MAJOR) * MAJOR;
        for (let nm = m0; nm <= view.xhi + EPS; nm += MAJOR) {
          const x = nm2x(nm);
          ctx.beginPath(); ctx.moveTo(x, baseY); ctx.lineTo(x, baseY - 10); ctx.stroke();
        }
      }

      // labels
      ctx.fillStyle = '#d6e3ff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.font = '11px system-ui, sans-serif';

      if (fine) {
        // world-anchored integer labels with non-overlap
        const i0 = Math.ceil(view.xlo), i1 = Math.floor(view.xhi);
        if (i0 <= i1) {
          // compute max label width in this window
          let wmax = 0;
          for (let i = i0; i <= i1; i++) wmax = Math.max(wmax, ctx.measureText(String(i)).width);
          const PAD = 8;                                     // px padding between labels
          const needPx = wmax + PAD;
          const step = Math.max(1, Math.ceil(needPx / pxPerNm)); // nm between labels

          // anchor to 0 nm so parity is stable (no odd/even flip-flop)
          const anchor = 0;
          let start = Math.ceil((i0 - anchor) / step) * step + anchor;

          for (let i = start; i <= i1; i += step) {
            const x = nm2x(i);
            const text = String(i);
            ctx.save();
            ctx.strokeStyle = 'rgba(0,0,0,0.55)'; ctx.lineWidth = 3;
            ctx.strokeText(text, x, baseY - 12);
            ctx.fillText(text, x, baseY - 12);
            ctx.restore();
          }
        }
      } else {
        // coarse tiers: dynamic label skipping
        const MIN_LABEL_PX = 36;
        let labelStep = MAJOR;
        while (pxPerNm * labelStep < MIN_LABEL_PX) labelStep *= 2;

        let m0 = Math.ceil(view.xlo / MAJOR) * MAJOR;
        for (let nm = m0; nm <= view.xhi + EPS; nm += MAJOR) {
          if (Math.abs(nm % labelStep) < 1e-6) {
            const x = nm2x(nm);
            const txt = String(Math.round(nm));
            ctx.save();
            ctx.strokeStyle = 'rgba(0,0,0,0.55)'; ctx.lineWidth = 3;
            ctx.strokeText(txt, x, baseY - 12);
            ctx.fillText(txt, x, baseY - 12);
            ctx.restore();
          }
        }
      }
    }


    // Stable 32-bit FNV-1a hash
    function fnv1a(str) {
      let h = 0x811c9dc5;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
      }
      return h >>> 0; // unsigned
    }

    // Change this to get a new (still-fixed) shuffle
    const SHUFFLE_SALT = 'galaxy-shuffle-v1';

    // Returns a permutation of indices in a deterministic pseudo-random order
    function stableShuffleOrder(arr) {
      const rows = arr.map((d, i) => {
        const key = String(d.id ?? d.name ?? i);
        const hash = fnv1a(SHUFFLE_SALT + '|' + key);
        return { i, hash };
      });
      rows.sort((a, b) => (a.hash - b.hash) || (a.i - b.i)); // tie-break by original index
      return rows.map(r => r.i);
    }

    function loadJSON(obj) {
      // apply deterministic shuffle
      const order = stableShuffleOrder(obj);
      data = order.map(i => obj[i]);

      objSel.innerHTML = '';
      data.forEach((d, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        const origName = (d.name && String(d.name).trim())
          ? d.name
          : (d.id ? d.id : `Obj ${i + 1}`);
        const galLabel = `Galaxy ${idxToLetters(i)}`; // A, B, C...
        opt.textContent = galLabel;
        opt.title = origName; // tooltip shows the real name
        objSel.appendChild(opt);
      });

      computeGlobalStats();
      current = 0; objSel.value = '0'; applySelection();

      if (document.getElementById('mapOverlay').style.display !== 'none') {
        buildMapPoints(); drawMap();
      }
    }

    function applySelection() {
      const d = data[current]; if (!d) return;
      currentZ = Number.isFinite(+d.z) ? +d.z : 0;
      zInput.value = String(currentZ);  // no toFixed()
      [view.xlo, view.xhi] = [VIS_MIN_NM, VIS_MAX_NM];
      if (yScaleSel.value === 'abs') updateAbsYRange();
      else {
        const ft = transformFluxAuto(d.flux || []);
        const ql = percentile(ft, 0.01), qh = percentile(ft, 0.999);
        const span = qh - ql || 1;
        view.ylo = ql - 0.05 * span;
        view.yhi = qh + 0.25 * span;
      }
      const img = document.getElementById('cutout');
      img.src = (d.image && d.image.path) ? d.image.path : "";
      document.getElementById('cutoutCaption').textContent = (d.name?.trim?.() ? d.name : (d.id || ''));
      hideResetButton(); drawLegend(); draw();
    }

    function updateHover(e) {
      const rect = canvas.getBoundingClientRect();
      const pt = (e.touches && e.touches.length) ? e.touches[0] : e;
      const x = pt.clientX - rect.left;
      const y = pt.clientY - rect.top;

      const { L, R, T, B } = getPlotRect();
      hoverYpx = Math.max(T, Math.min(B, y));   // remember pointer Y (clamped)

      if (x >= L && x <= R && y >= T && y <= B) {
        const frac = (x - L) / Math.max(1, (R - L));
        hoverNm = view.xlo + frac * (view.xhi - view.xlo);
      } else {
        hoverNm = null; hoverYpx = null;
      }
    }


    // Baseline absolute transform (gain-independent)
    function transformFluxAbsBase(f) {
      const s0 = 3 * GLOBAL.mad;                // fixed softness
      return f.map(v => Math.asinh((v - GLOBAL.med) / s0));
    }

    const VIS_SPAN = VIS_MAX_NM - VIS_MIN_NM;
    function fitSpanToVisible(center, span) {
      span = Math.max(MIN_X_SPAN, Math.min(span, VIS_SPAN));
      let lo = center - 0.5 * span;
      let hi = center + 0.5 * span;
      if (lo < VIS_MIN_NM) { lo = VIS_MIN_NM; hi = lo + span; }
      if (hi > VIS_MAX_NM) { hi = VIS_MAX_NM; lo = hi - span; }
      return [lo, hi];
    }

    function lowerBound(a, x) { // first i with a[i] >= x
      let lo = 0, hi = a.length;
      while (lo < hi) { const mid = (lo + hi) >> 1; (a[mid] < x) ? lo = mid + 1 : hi = mid; }
      return lo;
    }
    function sampleLinear(Xnm, Y, nm) {
      if (!Xnm.length) return 0;
      if (nm <= Xnm[0]) return Y[0];
      if (nm >= Xnm[Xnm.length - 1]) return Y[Y.length - 1];
      const i = Math.max(1, lowerBound(Xnm, nm));
      const x0 = Xnm[i - 1], x1 = Xnm[i], t = (nm - x0) / Math.max(1e-9, x1 - x0);
      return Y[i - 1] * (1 - t) + Y[i] * t;
    }

    function drawSpectroscope(L, R, T, B, W, H, Xnm, Ft) {
      // normalize contrast
      const ql = percentile(Ft, 0.10), qh = percentile(Ft, 0.995);
      const span = Math.max(1e-9, qh - ql);

      const nmLo = view.xlo, nmHi = view.xhi, nmSpan = nmHi - nmLo;

      // render a single 1-pixel-tall strip in device pixels, then scale up
      const dpr = window.devicePixelRatio || 1;
      const wpx = Math.max(1, Math.floor(W * dpr));

      const off = drawSpectroscope._off || (drawSpectroscope._off = document.createElement('canvas'));
      off.width = wpx; off.height = 1;
      const octx = off.getContext('2d', { willReadFrequently: true });
      const img = octx.createImageData(wpx, 1);
      const buf = img.data;

      for (let x = 0; x < wpx; x++) {
        const frac = x / Math.max(1, wpx - 1);
        const nm = nmLo + frac * nmSpan;

        // sample flux and map to 0..1 intensity
        let v = (sampleLinear(Xnm, Ft, nm) - ql) / span;
        if (v < 0) v = 0; else if (v > 1) v = 1;

        // wavelength color, then modulate RGB by intensity (opaque alpha)
        const [r, g, b] = wavelengthToRGB(nm);
        const k = 0.08 + 0.92 * v;            // contrast floor
        const i = x * 4;
        buf[i + 0] = Math.round(r * k);
        buf[i + 1] = Math.round(g * k);
        buf[i + 2] = Math.round(b * k);
        buf[i + 3] = 255;                     // opaque avoids edge blending seams
      }

      octx.putImageData(img, 0, 0);

      const prevSmooth = ctx.imageSmoothingEnabled;
      ctx.imageSmoothingEnabled = false;      // pixel-perfect upscaling
      ctx.drawImage(off, L, T, W, H);
      ctx.imageSmoothingEnabled = prevSmooth;

      // bezel
      ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
      ctx.strokeRect(L + 0.5, T + 0.5, W - 1, H - 1);
    }


    function wavelengthToRGB(nm) {
      // 380–780 nm -> [r,g,b] in 0–255
      let r = 0, g = 0, b = 0, a = 1, t = 0, wl = nm;
      if (wl < 380) wl = 380; if (wl > 780) wl = 780;
      if (wl < 440) { r = -(wl - 440) / (440 - 380); g = 0; b = 1; a = 0.3 + 0.7 * (wl - 380) / (60); }
      else if (wl < 490) { r = 0; g = (wl - 440) / (490 - 440); b = 1; }
      else if (wl < 510) { r = 0; g = 1; b = -(wl - 510) / (510 - 490); }
      else if (wl < 580) { r = (wl - 510) / (580 - 510); g = 1; b = 0; }
      else if (wl < 645) { r = 1; g = -(wl - 645) / (645 - 580); b = 0; }
      else { r = 1; g = 0; b = 0; a = 0.3 + 0.7 * (780 - wl) / (780 - 645); }
      const gamma = 0.8;
      r = Math.round(255 * Math.pow(r * a, gamma));
      g = Math.round(255 * Math.pow(g * a, gamma));
      b = Math.round(255 * Math.pow(b * a, gamma));
      return [r, g, b];
    }
    function rgb(r, g, b) { return `rgb(${r},${g},${b})`; }

    function percentile(a, p) {
      const b = [...a].sort((x, y) => x - y), n = b.length;
      if (n === 0) return 0;
      const i = (n - 1) * p, lo = Math.floor(i), hi = Math.ceil(i), h = i - lo;
      return (1 - h) * b[lo] + h * b[hi];
    }
    function median(a) { return percentile(a, 0.5); }
    function transformFlux(f) {
      // asinh works with negatives and compresses peaks
      const m = median(f);
      const mad = median(f.map(v => Math.abs(v - m))) || 1;
      const s = 3 * mad;                 // softness
      return f.map(v => Math.asinh((v - m) / s));
    }

    function x2px(x) { const w = canvas.clientWidth; return (x - view.xlo) / (view.xhi - view.xlo) * w; }
    function y2px(y) { const h = canvas.clientHeight; return h - (y - view.ylo) / (view.yhi - view.ylo) * h; }

    function drawLegend() {
      const z = currentZ;
      legend.textContent = REST_LINES.map(([lab, wlA]) => {
        const restVacA = airToVacAA(wlA);
        const obsNm = ((modeSel.value === 'rest') ? restVacA : restVacA * (1 + z)) * A2NM;
        return `${lab}: ${obsNm.toFixed(2)} nm`; // show 0.01 nm if you like
      }).join('  |  ');
    }

    function draw() {
      const d = data[current]; if (!d) return;

      // clamp x-range to visible each draw
      if (typeof clampXToVisible === 'function') {
        const center = 0.5 * (view.xlo + view.xhi);
        const span = (view.xhi - view.xlo);
        [view.xlo, view.xhi] = fitSpanToVisible(center, span);
      }

      const w = canvas.clientWidth, h = canvas.clientHeight;
      const L = 40, R = w - 10, T = 10, B = h - 30, W = R - L, H = B - T;

      const z = currentZ;
      const mode = modeSel.value;
      const wlObsA = (mode === 'rest') ? d.wavelength_A.map(w => w / (1 + z)) : d.wavelength_A;
      const X = wlObsA.map(w => w * A2NM); // nm

      const g = parseFloat(gain.value) || 1;
      const fl = (yScaleSel.value === 'abs')
        ? transformFluxAbsBase(d.flux).map(v => v * g)   // slider acts here (chart)
        : transformFluxAuto(d.flux);                      // chart (auto) ignores gain by design

      // spectroscope needs gain regardless of Y mode
      const flSpectro = (yScaleSel.value === 'abs'
        ? transformFluxAbsBase(d.flux)
        : transformFluxAuto(d.flux)
      ).map(v => v * g);

      // mappers over the plotting rect
      const x2 = x => L + (x - view.xlo) / (view.xhi - view.xlo) * W;
      const y2 = y => B - (y - view.ylo) / (view.yhi - view.ylo) * H;

      ctx.clearRect(0, 0, w, h);

      // --- branch: spectroscope vs chart ---
      if (spectroChk && spectroChk.checked) {
        // spectroscope strip (no axes, no draggable scale)
        drawSpectroscope(L, R, T, B, W, H, X, flSpectro);
      } else {
        // axes
        ctx.lineWidth = 1; ctx.strokeStyle = '#333';
        ctx.beginPath(); ctx.moveTo(L, T); ctx.lineTo(L, B); ctx.lineTo(R, B); ctx.stroke();

        // wavelength scale (draggable baseline)
        drawWavelengthScale(L, R, T, B, W);

        // spectrum with wavelength-colored segments, clipped to visible band
        let pxPrev = null, pyPrev = null, nmPrev = null;
        const STEP = 1;
        for (let i = 0; i < X.length; i += STEP) {
          const nm = X[i];
          if (nm < view.xlo || nm > view.xhi) { pxPrev = pyPrev = nmPrev = null; continue; }
          const px = x2(nm);
          const py = y2(fl[i]);

          if (pxPrev !== null) {
            const nmMid = 0.5 * (nmPrev + nm);
            const [r, gch, b] = wavelengthToRGB(nmMid);
            ctx.strokeStyle = rgb(r, gch, b);
            ctx.beginPath(); ctx.moveTo(pxPrev, pyPrev); ctx.lineTo(px, py); ctx.stroke();
          }
          pxPrev = px; pyPrev = py; nmPrev = nm;
        }
        pxPrev = px; pyPrev = py; nmPrev = nm;
      }

      // rest lines + labels (collision-aware stacking)
      if (showLines.checked) {
        const spectro = !!(spectroChk && spectroChk.checked);
        ctx.strokeStyle = spectro ? 'rgba(255,255,255,0.35)' : '#444';
        ctx.fillStyle = spectro ? 'rgba(230,230,230,0.95)' : '#888';
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.font = '10px system-ui, sans-serif';

        const labelTop = legendLabelTop(T);
        const rowH = 24;                               // pixels between stacked rows
        const maxRows = Math.max(1, Math.floor((B - labelTop - 20) / rowH));
        const gapPx = 40;                               // min horizontal gap to reuse a row

        // collect visible lines first
        const items = [];
        for (const [lab, wlA0] of REST_LINES) {
          const restVacA = airToVacAA(wlA0);
          const xObsNm = ((mode === 'rest') ? restVacA : restVacA * (1 + z)) * A2NM;
          if (xObsNm < view.xlo || xObsNm > view.xhi) continue;
          const px = x2(xObsNm);
          items.push({ lab, nm: xObsNm, px });
        }
        // left→right and assign stacking rows to avoid overlap (e.g., Na D₁/D₂)
        items.sort((a, b) => a.px - b.px);
        layoutLineRows(items, gapPx, maxRows);

        // draw
        for (const it of items) {
          const y0 = labelTop + it.row * rowH;
          ctx.beginPath(); ctx.moveTo(it.px, T + 2); ctx.lineTo(it.px, B); ctx.stroke();
          ctx.fillText(it.lab, it.px, y0);
          ctx.fillText(`${it.nm.toFixed(1)} nm`, it.px, y0 + 12);
        }
      }

      // axis labels only for chart mode
      if (!(spectroChk && spectroChk.checked)) {
        ctx.fillStyle = '#aaa';
        ctx.textAlign = 'left'; ctx.fillText('Flux (arb.)', L - 32, T + 14);
        ctx.textAlign = 'right'; ctx.fillText(mode === 'rest' ? 'Rest wavelength (nm)' : 'Observed wavelength (nm)', R, B + 6);
      }

      // --- hover measuring line ---
      if (hoverNm !== null && hoverNm >= view.xlo && hoverNm <= view.xhi) {
        const w = canvas.clientWidth, h = canvas.clientHeight;
        const L = 40, R = w - 10, T = 10, B = h - 30, W = R - L;
        const x2 = x => L + (x - view.xlo) / (view.xhi - view.xlo) * W;

        const px = x2(hoverNm);
        const [r, gch, b] = wavelengthToRGB(hoverNm);
        const col = `rgb(${r},${gch},${b})`;

        ctx.save();

        // colored vertical line with a soft glow
        ctx.strokeStyle = col;
        ctx.lineWidth = 1;
        ctx.shadowColor = `rgba(${r},${gch},${b},0.6)`;
        ctx.shadowBlur = 6;
        ctx.beginPath(); ctx.moveTo(px, T + 2); ctx.lineTo(px, B); ctx.stroke();

        // label position: try to keep it fully visible in the plot
        const ly = Math.max(T + 12, Math.min(B - 12, (hoverYpx ?? B) - 10));

        // label above pointer
        const label = `${hoverNm.toFixed(1)} nm`;
        ctx.font = 'bold 14px system-ui, sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
        ctx.lineWidth = 3; ctx.strokeStyle = 'rgba(0,0,0,0.65)';
        ctx.strokeText(label, px, ly);
        ctx.fillStyle = col;
        ctx.fillText(label, px, ly);
        ctx.restore();
      }

      if (resetBtnVisible) {
        const pad = 10;
        const { L, R, T, B } = getPlotRect();
        const btnH = 26, btnPadX = 12, radius = 14;
        const label = 'Reset display';

        ctx.save();
        ctx.font = '600 13px system-ui, sans-serif';
        const textW = ctx.measureText(label).width;
        const btnW = Math.round(textW + 2 * btnPadX);

        // place aesthetically above/right of x-axis, clear of axes ticks
        const x = R - btnW - pad;
        const y = B - btnH - pad;

        // rounded pill
        ctx.beginPath();
        const r = radius, w = btnW, h = btnH;
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();

        // background with subtle shadow
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.shadowColor = 'rgba(0,0,0,0.6)';
        ctx.shadowBlur = 6;
        ctx.fill();
        ctx.shadowBlur = 0;

        // border
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#3a3a3a';
        ctx.stroke();

        // text
        ctx.fillStyle = '#e9f0ff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, x + w / 2, y + h / 2);

        ctx.restore();

        // record hitbox in CSS pixels
        resetBtnRect = { x, y, w: btnW, h: btnH };
      } else {
        resetBtnRect = null;
      }
    }

    const spectroChk = document.getElementById('spectro');
    spectroChk.addEventListener('change', () => { hideResetButton(); draw(); });

    let draggingPlot = false, lastX = 0, lastY = 0;

    // MOUSE
    canvas.addEventListener('mousedown', e => {
      stopXInertia();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      // check reset button hit
      const mx = e.clientX - rect.left, my = e.clientY - rect.top;
      if (resetBtnRect && mx >= resetBtnRect.x && mx <= resetBtnRect.x + resetBtnRect.w
        && my >= resetBtnRect.y && my <= resetBtnRect.y + resetBtnRect.h) {
        e.preventDefault(); e.stopPropagation();
        resetDisplay();
        return;
      }

      if (hitScaleAt(x, y)) {
        draggingScale = true;
        const { B } = getPlotRect();
        scaleGrabOffset = (scaleY == null ? B : scaleY) - y;
        canvas.style.cursor = 'grabbing';   // <—
        e.preventDefault(); e.stopPropagation();
        return;
      }
      // start plot drag
      draggingPlot = true;
      lastX = e.clientX; lastY = e.clientY;
      updateHover(e);
    }, { passive: false });

    window.addEventListener('mousemove', e => {
      if (draggingScale) {
        const rect = canvas.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const { T, B } = getPlotRect();
        scaleY = Math.max(T + 12, Math.min(B, y + scaleGrabOffset));
        draw();
        return;
      }
      if (draggingPlot) {
        const dx = e.clientX - lastX, dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;

        const wx = view.xhi - view.xlo, wy = view.yhi - view.ylo;
        const fx = -dx / canvas.clientWidth;
        view.xlo += fx * wx; view.xhi += fx * wx;
        if (yScaleSel.value !== 'abs') {
          const raw = (dy / canvas.clientHeight) * wy * Y_MOUSE_SLOW;
          const s = clampYPan(raw);
          view.ylo += s; view.yhi += s;
        }
        draw();
        showResetButton();
      }
    });

    window.addEventListener('mouseup', () => {
      draggingPlot = false; draggingScale = false; canvas.style.cursor = scaleHover ? 'grab' : 'auto';
    });

    canvas.addEventListener('mousemove', e => { updateScaleHover(e); updateHover(e); draw(); }); // hover only
    canvas.addEventListener('mouseleave', () => {
      hoverNm = null;
      hoverYpx = null;
      scaleHover = false;
      if (!draggingScale) canvas.style.cursor = 'auto'; draw();
    });

    // TOUCH START
    canvas.addEventListener('touchstart', e => {
      stopXInertia();
      if (e.touches.length === 2) {
        twoTouchActive = true;
        draggingScale = false;                        // cancel any scale drag

        // pan anchor (Y)
        twoTouchPrevY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

        // pinch anchor (X)
        const rect = canvas.getBoundingClientRect();
        const { L, R, W } = getPlotRect();
        const mx = ((e.touches[0].clientX + e.touches[1].clientX) * 0.5) - rect.left;
        const clampedX = Math.max(L, Math.min(R, mx));
        const frac = (clampedX - L) / Math.max(1, W);
        pinchAnchorNm = view.xlo + frac * (view.xhi - view.xlo);

        // initial pinch distance
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        pinchPrevDist = Math.hypot(dx, dy);
        e.preventDefault();
        return;
      }

      if (e.touches.length === 1) {
        const rect = canvas.getBoundingClientRect();
        const t = e.touches[0];
        const x = t.clientX - rect.left, y = t.clientY - rect.top;
        updateHover(e);
        if (hitScaleAt(x, y)) {
          draggingScale = true;
          const { B } = getPlotRect();
          scaleGrabOffset = (scaleY == null ? B : scaleY) - y;
          e.preventDefault(); e.stopPropagation();
        }
      }
    }, { passive: false });

    // TOUCH MOVE (simultaneous Y-pan + X-zoom)
    canvas.addEventListener('touchmove', e => {
      if (twoTouchActive && e.touches.length === 2) {
        const rect = canvas.getBoundingClientRect();

        // ----- Y PAN (two-finger drag) -----
        const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        const dy = cy - twoTouchPrevY;
        twoTouchPrevY = cy;
        if (yScaleSel.value !== 'abs') {
          const ySpan = view.yhi - view.ylo;
          const raw = (dy / canvas.clientHeight) * ySpan * Y_FINGER_SLOW;
          const s = clampYPan(raw);
          view.ylo += s; view.yhi += s;
        }


        showResetButton();

        // ----- X ZOOM (pinch) -----
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy2 = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy2);
        if (pinchPrevDist > 0 && dist > 0) {
          const scale = dist / pinchPrevDist;       // >1 => fingers apart
          pinchPrevDist = dist;
          // zoom1D multiplies span by factor; bigger span = zoom out.
          const factor = 1 / scale;                 // apart => zoom IN
          let [lo, hi] = zoom1D(view.xlo, view.xhi, pinchAnchorNm, factor);
          [lo, hi] = fitSpanToVisible(0.5 * (lo + hi), (hi - lo));
          view.xlo = lo; view.xhi = hi;
        } else {
          pinchPrevDist = dist;
        }

        draw();
        e.preventDefault();
        return;
      }

      if (draggingScale && e.touches.length === 1) {
        const rect = canvas.getBoundingClientRect();
        const y = e.touches[0].clientY - rect.top;
        const { T, B } = getPlotRect();
        scaleY = Math.max(T + 12, Math.min(B, y + scaleGrabOffset));
        draw();
        e.preventDefault();
        return;
      }

      if (e.touches.length === 1) {
        updateHover(e);
        draw();
        e.preventDefault();
      }
    }, { passive: false });

    // TOUCH END/CANCEL
    canvas.addEventListener('touchend', e => {
      if (e.touches.length < 2) {
        twoTouchActive = false; twoTouchPrevY = null;
        pinchPrevDist = 0; pinchAnchorNm = null;
      }
      if (e.touches.length === 0) draggingScale = false;
    }, { passive: true });

    canvas.addEventListener('touchcancel', () => {
      twoTouchActive = false; twoTouchPrevY = null;
      pinchPrevDist = 0; pinchAnchorNm = null;
      draggingScale = false;
    }, { passive: true });


    const MIN_X_SPAN = 5;      // nm
    const MIN_Y_SPAN = 0.02;   // display units after transform

    function zoom1D(lo, hi, center, factor) {
      const span = (hi - lo) * factor;
      return [center - 0.5 * span, center + 0.5 * span];
    }
    function clampSpan(lo, hi, minSpan) {
      if ((hi - lo) < minSpan) {
        const mid = 0.5 * (lo + hi);
        lo = mid - 0.5 * minSpan; hi = mid + 0.5 * minSpan;
      }
      return [lo, hi];
    }

    function zoomXCentered(factor) {
      const center = 0.5 * (view.xlo + view.xhi);
      const span = (view.xhi - view.xlo) * factor;         // factor < 1 zoom in
      const [lo, hi] = fitSpanToVisible(center, span);
      view.xlo = lo; view.xhi = hi;
      showResetButton();
      draw();
    }

    function wheelZoomFactor(dy) {
      // smooth, OS/device-independent-ish
      // dy < 0 => zoom in (factor < 1), dy > 0 => zoom out
      return Math.exp(dy * 0.0012);
    }

    canvas.addEventListener('wheel', (e) => {
      // Zoom when ctrl or shift
      if (e.ctrlKey || e.shiftKey) {
        e.preventDefault();
        stopXInertia();
        zoomXCentered(Math.exp(e.deltaY * 0.0012));
        return;
      }

      const absX = Math.abs(e.deltaX), absY = Math.abs(e.deltaY);
      // Horizontal two-finger pan wins when it's dominant
      if (absX > absY * 0.75 && absX > 0.5) {
        e.preventDefault();
        // immediate pan
        const span = (view.xhi - view.xlo);
        const nmPerPx = span / Math.max(1, canvas.clientWidth);
        const dxNm = e.deltaX * nmPerPx;
        view.xlo += dxNm; view.xhi += dxNm;
        showResetButton();
        draw();

        // inertia: map deltaX to nm/ms
        const vx = (e.deltaX / Math.max(1, canvas.clientWidth)) * span * X_GAIN;
        startXInertia(vx);
        return;
      }

      // Otherwise: vertical pan (slow)
      e.preventDefault();
      stopXInertia();
      const ySpan = view.yhi - view.ylo;
      const raw = Math.sign(e.deltaY) * ySpan * (Y_WHEEL_SLOW * 0.01);
      const s = clampYPan(raw);
      view.ylo += s; view.yhi += s;

      showResetButton();
      draw();
    }, { passive: false });




    yScaleSel.addEventListener('change', () => {
      if (yScaleSel.value === 'abs') updateAbsYRange();
      else applySelection();
      hideResetButton();
      draw();
    });

    gain.addEventListener('input', () => {
      const g = parseFloat(gain.value) || 1;
      gainOut.textContent = '×' + g.toFixed(2);
      draw();
    });

    function setStatus(msg) { statusEl.textContent = msg; }

    objSel.addEventListener('change', () => { gain.value = 0.5; gainOut.textContent = "×0.50"; current = parseInt(objSel.value, 10); applySelection(); hideResetButton(); });
    modeSel.addEventListener('change', () => { hideResetButton(); drawLegend(); draw(); });
    applyZBtn.addEventListener('click', () => {
      const zVal = parseFloat(zInput.value);
      currentZ = Number.isFinite(zVal) ? zVal : 0;
      drawLegend(); draw();
    });
    document.getElementById('open').addEventListener('click', () => fileIn.click());
    fileIn.addEventListener('change', async () => {
      const f = fileIn.files[0]; if (!f) return;
      try {
        const obj = JSON.parse(await f.text()); if (!Array.isArray(obj)) throw new Error('JSON must be an array');
        loadJSON(obj); setStatus(`Loaded ${f.name} with ${obj.length} object(s)`);
      }
      catch (err) { setStatus('Invalid JSON: ' + err.message); }
    });

    fetch('spectra.json').then(r => {
      if (!r.ok) throw new Error('no spectra.json'); return r.json();
    }).then(obj => { loadJSON(obj); setStatus('Loaded spectra.json'); })
      .catch(() => setStatus('No local spectra.json. Use Open JSON.'));

    const showLines = document.getElementById('showLines');
    showLines.addEventListener('change', draw);

    resize();


    // ---- 3D Sky Map ----
    let showMapBtn, mapOverlay, mapCanvas, mapClose, mctx;
    const mapState = { rotX: 0, rotY: 0, scale: 1.2, dragging: false, lx: 0, ly: 0, centerRA: 0, centerDec: 0, pts: [], anim: null };

    window.addEventListener('DOMContentLoaded', () => {
      const showMapBtn = document.getElementById('showMap');
      const mapOverlay = document.getElementById('mapOverlay');
      const mapCanvas = document.getElementById('map3d');
      const mapClose = document.getElementById('mapClose');
      const mctx = mapCanvas.getContext('2d');

      const simDist = document.getElementById('simDist');

      // simple Hubble-law distance (low-z)
      const C_KMS = 299792.458, H0 = 70;  // km/s, km/s/Mpc
      const zToMpc = z => Math.max(0, (C_KMS / H0) * (Number(z) || 0));

      const mapState = {
        rotX: 0, rotY: 0,
        scale: 1.2,                 // zoom
        dragging: false, lx: 0, ly: 0,
        centerRA: 0, centerDec: 0,  // radians
        pts: [],                    // [{x,y,z,label,zval}]
        anim: null
      };

      // Helpers
      const DEG = Math.PI / 180;
      function rx(a, [x, y, z]) { const s = Math.sin(a), c = Math.cos(a); return [x, c * y - s * z, s * y + c * z]; }
      function ry(a, [x, y, z]) { const s = Math.sin(a), c = Math.cos(a); return [c * x + s * z, y, -s * x + c * z]; }
      function rz(a, [x, y, z]) { const s = Math.sin(a), c = Math.cos(a); return [c * x - s * y, s * x + c * y, z]; }
      function sphToVec(raDeg, decDeg) {
        const ra = raDeg * DEG, dec = decDeg * DEG;
        const cd = Math.cos(dec), sd = Math.sin(dec), cr = Math.cos(ra), sr = Math.sin(ra);
        return [cd * cr, cd * sr, sd];
      }
      function resizeMap() {
        const dpr = window.devicePixelRatio || 1;
        const rect = mapCanvas.getBoundingClientRect();
        mapCanvas.width = Math.max(1, Math.floor(rect.width * dpr));
        mapCanvas.height = Math.max(1, Math.floor(rect.height * dpr));
        mctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function buildMapPoints() {
        // center on currently selected object
        const d = data[current];
        let ra0 = 0, dec0 = 0;
        if (d && Number.isFinite(d.ra_deg) && Number.isFinite(d.dec_deg)) {
          ra0 = d.ra_deg * DEG;
          dec0 = d.dec_deg * DEG;
        }
        mapState.centerRA = ra0;
        mapState.centerDec = dec0;

        // distances for all (for normalization)
        const useDist = !!(simDist && simDist.checked);
        const dists = data.map(o => (o && Number.isFinite(o.z)) ? zToMpc(o.z) : 0);
        const maxD = dists.reduce((a, b) => Math.max(a, b), 0);

        mapState.pts = [];
        for (let i = 0; i < data.length; i++) {
          const o = data[i];
          if (!o || !Number.isFinite(o.ra_deg) || !Number.isFinite(o.dec_deg)) continue;

          const v = sphToVec(o.ra_deg, o.dec_deg); // unit vector
          // pre-rotate so selected is at front
          let p = rz(-ra0, v);
          p = rx(-dec0, p);

          const D = dists[i] || 0;
          // radius: flat shell when off, scaled 0.4..1.0 when on
          const r = (useDist && maxD > 0) ? (0.4 + 0.6 * (D / maxD)) : 1.0;

          mapState.pts.push({
            v: p,
            r,
            label: (o.name || o.id || 'obj'),
            zval: Number(o.z) || 0,
            isCurrent: (i === current)
          });
        }
      }

      function drawMap() {
        const w = mapCanvas.clientWidth, h = mapCanvas.clientHeight;
        mctx.clearRect(0, 0, w, h);

        // subtle background
        const g = mctx.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, Math.hypot(w, h) / 2);
        g.addColorStop(0, '#0b0b0b'); g.addColorStop(1, '#000');
        mctx.fillStyle = g; mctx.fillRect(0, 0, w, h);

        const pts2d = [];
        for (const p of mapState.pts) {
          // apply user rotation, then radial distance
          let q = ry(mapState.rotY, rx(mapState.rotX, p.v));
          q = [q[0] * p.r, q[1] * p.r, q[2] * p.r];

          // correct perspective (front => big)
          const camZ = 2.8;
          const z = camZ - q[2];
          if (z <= 0.05) continue;
          const f = mapState.scale * Math.min(w, h) * 0.42 / z;

          const x = w * 0.5 + q[0] * f;
          const y = h * 0.5 - q[1] * f;

          // color by z (blue→white→red), fade back hemisphere
          const zc = Math.max(-0.01, Math.min(0.05, p.zval));
          const t = (zc + 0.01) / 0.06;
          const rr = Math.round(200 * t + 55 * (1 - t));
          const bb = Math.round(200 * (1 - t) + 55 * t);
          const a = 0.35 + 0.65 * ((q[2] + 1) * 0.5); // front brighter

          pts2d.push({ x, y, z, r: rr, g: 220, b: bb, a, label: p.label, isCur: p.isCurrent });
        }

        // sphere rim (unit radius)
        mctx.strokeStyle = '#222'; mctx.lineWidth = 1;
        mctx.beginPath();
        mctx.arc(w / 2, h / 2, Math.min(w, h) * 0.42 * mapState.scale, 0, Math.PI * 2);
        mctx.stroke();

        // back-to-front
        pts2d.sort((A, B) => B.z - A.z);

        // draw normals
        for (const p of pts2d) {
          if (p.isCur) continue;
          mctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${p.a.toFixed(3)})`;
          mctx.beginPath(); mctx.arc(p.x, p.y, 3, 0, Math.PI * 2); mctx.fill();
        }

        // highlight current
        const cur = pts2d.find(p => p.isCur);
        if (cur) {
          mctx.save();
          mctx.shadowColor = 'rgba(0,0,0,0.7)'; mctx.shadowBlur = 6;
          mctx.fillStyle = '#fff';
          mctx.beginPath(); mctx.arc(cur.x, cur.y, 5, 0, Math.PI * 2); mctx.fill();
          mctx.lineWidth = 2; mctx.strokeStyle = 'rgba(0,0,0,0.6)'; mctx.stroke();
          mctx.shadowColor = 'transparent'; mctx.shadowBlur = 0;
          mctx.font = '600 13px system-ui, sans-serif';
          mctx.textAlign = 'left'; mctx.textBaseline = 'middle';
          mctx.fillStyle = '#fff';
          const label = (data[current]?.name || data[current]?.id || 'current');
          mctx.fillText(label, cur.x + 10, cur.y);
          mctx.restore();
        }

        // crosshair
        mctx.strokeStyle = 'rgba(255,255,255,.08)';
        mctx.beginPath();
        mctx.moveTo(w / 2 - 10, h / 2); mctx.lineTo(w / 2 + 10, h / 2);
        mctx.moveTo(w / 2, h / 2 - 10); mctx.lineTo(w / 2, h / 2 + 10);
        mctx.stroke();

        // --- Milky Way center marker ---
        const cx = w * 0.5, cy = h * 0.5;
        mctx.save();
        // dot with subtle outline
        mctx.fillStyle = '#ffd65a';           // warm gold to stand out
        mctx.strokeStyle = 'rgba(0,0,0,.6)';
        mctx.lineWidth = 2;
        mctx.beginPath(); mctx.arc(cx, cy, 4, 0, Math.PI * 2); mctx.fill(); mctx.stroke();

        // label next to the dot (outlined for readability)
        const label = 'Milky Way';
        mctx.font = 'bold 12px system-ui, sans-serif';
        mctx.textAlign = 'left';
        mctx.textBaseline = 'middle';
        mctx.strokeStyle = 'rgba(0,0,0,.7)';
        mctx.lineWidth = 3;
        mctx.strokeText(label, cx + 8, cy);
        mctx.fillStyle = '#fff';
        mctx.fillText(label, cx + 8, cy);
        mctx.restore();
      }


      function openMap() {
        mapOverlay.style.display = 'block';          // show first
        requestAnimationFrame(() => {                // wait 1 frame so layout exists
          resizeMap();                               // now clientWidth/Height are > 0
          buildMapPoints();
          drawMap();
        });
      }
      function closeMap() {
        mapOverlay.style.display = 'none';
        if (mapState.anim) cancelAnimationFrame(mapState.anim);
      }



      // events
      // ---- TOUCH support: one finger rotate, two fingers pinch-zoom ----
      let touchMode = 'none';
      let pinchPrevDist = 0;

      function touchDist(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.hypot(dx, dy);
      }

      mapCanvas.addEventListener('touchstart', e => {
        if (e.touches.length === 1) {
          // rotate
          touchMode = 'rotate';
          mapState.dragging = true;
          mapState.lx = e.touches[0].clientX;
          mapState.ly = e.touches[0].clientY;
        } else if (e.touches.length >= 2) {
          // pinch
          touchMode = 'pinch';
          mapState.dragging = false;
          pinchPrevDist = touchDist(e.touches);
        }
        e.preventDefault();
      }, { passive: false });

      mapCanvas.addEventListener('touchmove', e => {
        if (touchMode === 'rotate' && e.touches.length === 1) {
          const t = e.touches[0];
          const dx = t.clientX - mapState.lx;
          const dy = t.clientY - mapState.ly;
          mapState.lx = t.clientX;
          mapState.ly = t.clientY;

          mapState.rotY += dx * 0.005;
          mapState.rotX += dy * 0.005;
          mapState.rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mapState.rotX));
          drawMap();
        } else if (e.touches.length >= 2) {
          // pinch zoom
          const d = touchDist(e.touches);
          if (pinchPrevDist > 0) {
            const factor = d / pinchPrevDist;          // >1 zoom in, <1 zoom out
            mapState.scale *= factor;
            mapState.scale = Math.max(0.6, Math.min(3.0, mapState.scale));
            drawMap();
          }
          pinchPrevDist = d;
        }
        e.preventDefault();
      }, { passive: false });

      mapCanvas.addEventListener('touchend', e => {
        if (e.touches.length === 0) {
          touchMode = 'none';
          mapState.dragging = false;
          pinchPrevDist = 0;
        } else if (e.touches.length === 1) {
          // fall back to rotate with remaining finger
          touchMode = 'rotate';
          mapState.dragging = true;
          mapState.lx = e.touches[0].clientX;
          mapState.ly = e.touches[0].clientY;
          pinchPrevDist = 0;
        }
        e.preventDefault();
      }, { passive: false });

      mapCanvas.addEventListener('touchcancel', () => {
        touchMode = 'none';
        mapState.dragging = false;
        pinchPrevDist = 0;
      }, { passive: false });

      showMapBtn.addEventListener('click', openMap);
      mapClose.addEventListener('click', closeMap);
      simDist.addEventListener('change', () => {
        if (mapOverlay.style.display !== 'none') { buildMapPoints(); drawMap(); }
      });
      objSel.addEventListener('change', () => {
        if (mapOverlay.style.display !== 'none') { buildMapPoints(); drawMap(); }
      });
      window.addEventListener('resize', () => { if (mapOverlay.style.display !== 'none') { resizeMap(); drawMap(); } });
      document.addEventListener('keydown', e => { if (e.key === 'Escape' && mapOverlay.style.display !== 'none') closeMap(); });

      mapCanvas.addEventListener('mousedown', e => { mapState.dragging = true; mapState.lx = e.clientX; mapState.ly = e.clientY; });
      window.addEventListener('mouseup', () => { mapState.dragging = false; });
      window.addEventListener('mousemove', e => {
        if (!mapState.dragging) return;
        const dx = e.clientX - mapState.lx, dy = e.clientY - mapState.ly;
        mapState.lx = e.clientX; mapState.ly = e.clientY;
        // adjust sensitivity; clamp X rotation to avoid flipping too fast
        mapState.rotY += dx * 0.005;
        mapState.rotX += dy * 0.005;
        mapState.rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mapState.rotX));
        drawMap();
      });
      mapCanvas.addEventListener('wheel', e => {
        e.preventDefault();
        const dir = e.deltaY > 0 ? +1 : -1;       // down=out, up=in
        const zstep = 1.1;
        mapState.scale *= (dir > 0 ? 1 / zstep : zstep);
        mapState.scale = Math.max(0.6, Math.min(3.0, mapState.scale));
        drawMap();
      }, { passive: false });
    });

    const sidePanel = document.getElementById('sidePanel');
    const togglePanelBtn = document.getElementById('togglePanel');
    document.addEventListener('keydown', e => { if (e.key.toLowerCase() === 'r') resetDisplay(); });
    const layout = document.querySelector('main.layout');
    function setPanelCollapsed(collapsed) {
      document.body.classList.toggle('panel-collapsed', collapsed);
      togglePanelBtn.setAttribute('aria-expanded', String(!collapsed));
      togglePanelBtn.setAttribute('aria-pressed', String(collapsed));
      const onEnd = (e) => {
        if (e.propertyName === 'grid-template-columns' || e.propertyName === 'max-height') {
          layout.removeEventListener('transitionend', onEnd);
          resize(); draw();
        }
      };
      layout.addEventListener('transitionend', onEnd);
    }
    togglePanelBtn.addEventListener('click', () => {
      const collapsed = !document.body.classList.contains('panel-collapsed');
      setPanelCollapsed(collapsed);
    });

    // optional: remember state
    try {
      const saved = localStorage.getItem('panelCollapsed') === '1';
      if (saved) setPanelCollapsed(true);
      new MutationObserver(() => {
        const c = document.body.classList.contains('panel-collapsed');
        localStorage.setItem('panelCollapsed', c ? '1' : '0');
      }).observe(document.body, { attributes: true, attributeFilter: ['class'] });
    } catch { }
  </script>
  <div id="mapOverlay" style="display:none">
    <canvas id="map3d"></canvas>
    <div id="mapControls">
      <label><input id="simDist" type="checkbox"> Simulate distance</label>
    </div>
    <button id="mapClose" aria-label="Close Map">✕</button>
  </div>
  </body>

</html>