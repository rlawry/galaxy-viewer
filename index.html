<!doctype html>
<html lang='en'>

<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <title>Galaxy Spectra Redshift Viewer</title>
  <style>
    :root {
      color-scheme: dark light;
    }

    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #0b0b0b;
      color: #e5e5e5;
    }

    header,
    footer {
      padding: 8px 12px;
      background: #111;
      border-bottom: 1px solid #222;
    }

    footer {
      border-top: 1px solid #222;
      border-bottom: none;
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    button,
    select,
    input {
      background: #181818;
      color: #ddd;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 6px 8px;
    }

    #canvas {
      display: block;
      width: 100vw;
      height: calc(100vh - 150px);
      background: #0a0a0a;
    }

    .pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #333;
      background: #151515;
    }

    #legend {
      font-size: 12px;
    }

    /* overlay */

    #cutoutWrap {
      position: fixed;
      right: 12px;
      bottom: 12px;
      width: 280px;
      height: 280px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #000;
      z-index: 20;
      overflow: hidden;
    }

    #cutout {
      width: 100%;
      height: 100%;
      object-fit: contain;

      opacity: .9;
      pointer-events: none;
    }
  </style>

</head>

<body>
  <header>
    <div class='row'>
      <label>Object</label><select id='obj'></select>
      <label>Mode</label>
      <select id='mode'>
        <option value='observed'>Observed</option>
        <option value='rest'>Rest-frame (divide by 1+z)</option>
      </select>
      <label>z</label><input id='z' type='number' step='0.0001' value='0' style='width:110px'>
      <button id='applyZ'>Apply z</button>
      <button id='open'>Open JSON…</button>
      <span class='pill' id='status'>No file loaded</span>
    </div>
    <label>Scaling</label>
    <select id="yscale">
      <option value="auto">Auto</option>
      <option value="abs" selected>Absolute</option>
    </select>
    <label>Flux scale</label>
    <input id="gain" type="range" min="0.25" max="10" step="0.05" value="1">
    <output id="gainOut" class="pill">×1.00</output>
    <label><input id="showLines" type="checkbox"> Show element lines</label>
  </header>
  <canvas id='canvas'></canvas>
  <style>

  </style>
  <footer>
    <div class='row'>
      <div id='legend'></div>
      <div style='margin-left:auto'><span class='pill'>Vertical lines: key rest wavelengths</span></div>
    </div>
  </footer>
  <input type='file' id='file' accept='.json' style='display:none'>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const objSel = document.getElementById('obj');
    const modeSel = document.getElementById('mode');
    const zInput = document.getElementById('z');
    const applyZBtn = document.getElementById('applyZ');
    const statusEl = document.getElementById('status');
    const openBtn = document.getElementById('open');
    const fileIn = document.getElementById('file');
    const legend = document.getElementById('legend');
    let hoverNm = null;  // current hover wavelength in nm (or null)

    const REST_LINES = [
      //["[O II]", 3727.0],
      ["Hδ", 4101.74],
      ["Hγ", 4340.47],
      ["Hβ", 4861.33],
      //["[O III]", 4958.91],
      //["[O III]", 5006.84],
      ["Mg b", 5175.0],
      ["Na D", 5891.58],
      ["Hα", 6562.80],
      //["[N II]", 6583.45],
      //["[S II]", 6716.44],
      //["[S II]", 6730.82],
      //["Ca K", 3933.66],
      //["Ca H", 3968.47],
    ];
    const A2NM = 0.1;

    let data = []; let view = { xlo: 3500, xhi: 9000, ylo: -1, yhi: 5 }; let current = 0;

    const yScaleSel = document.getElementById('yscale');
    const gain = document.getElementById('gain');
    const gainOut = document.getElementById('gainOut');

    let GLOBAL = { med: 0, mad: 1, qlo: 0, qhi: 0 };

    const VIS_MIN_NM = 380, VIS_MAX_NM = 740;   // visible band
    function clampXToVisible(xlo, xhi) {
      let lo = Math.max(VIS_MIN_NM, xlo);
      let hi = Math.min(VIS_MAX_NM, xhi);
      if ((hi - lo) < MIN_X_SPAN) {
        const mid = Math.min(Math.max(0.5 * (xlo + xhi), VIS_MIN_NM + 0.5 * MIN_X_SPAN),
          VIS_MAX_NM - 0.5 * MIN_X_SPAN);
        lo = mid - 0.5 * MIN_X_SPAN; hi = mid + 0.5 * MIN_X_SPAN;
      }
      return [lo, hi];
    }

    function computeGlobalStats() {
      const all = data.flatMap(d => d.flux || []);
      if (!all.length) { GLOBAL = { med: 0, mad: 1, qlo: -1, qhi: 1 }; return; }
      const m = median(all);
      const mad = median(all.map(v => Math.abs(v - m))) || 1;
      const qlo = percentile(all, 0.01);
      const qhi = percentile(all, 0.99);
      GLOBAL = { med: m, mad, qlo, qhi };
    }

    function asinhMap(val, g) {
      const s = (3 * GLOBAL.mad) / g;              // smaller s => steeper
      return Math.asinh((val - GLOBAL.med) / s);
    }

    // rename old transformFlux -> transformFluxAuto
    function transformFluxAuto(f) {
      const m = median(f);
      const mad = median(f.map(v => Math.abs(v - m))) || 1;
      const s = 3 * mad;
      return f.map(v => Math.asinh((v - m) / s));
    }

    function transformFluxAbsBase(f) {
      const s0 = 3 * GLOBAL.mad;
      return f.map(v => Math.asinh((v - GLOBAL.med) / s0));
    }

    function resize() {
      const dpr = window.devicePixelRatio || 1; canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr); ctx.setTransform(dpr, 0, 0, dpr, 0, 0); draw();
    }
    window.addEventListener('resize', resize);

    function setStatus(msg) { statusEl.textContent = msg; }

    function loadJSON(obj) {
      data = obj; objSel.innerHTML = '';
      data.forEach((d, i) => {
        const opt = document.createElement('option');
        opt.value = i;
        const label = (d.name && String(d.name).trim()) ? d.name
          : (d.id ? d.id : `Obj ${i + 1}`);
        opt.textContent = `${label}  z=${d.z ?? '?'}`;
        if (d.id) opt.title = d.id;
        objSel.appendChild(opt);
      });
      computeGlobalStats();
      current = 0; objSel.value = '0'; applySelection();
    }

    function applySelection() {
      const d = data[current]; if (!d) return;
      const z = Number.isFinite(d.z) ? Number(d.z) : 0; zInput.value = z.toFixed(4);

      [view.xlo, view.xhi] = [VIS_MIN_NM, VIS_MAX_NM];

      if (yScaleSel.value === 'abs') {
        const s0 = 3 * GLOBAL.mad;
        const y0lo = Math.asinh((GLOBAL.qlo - GLOBAL.med) / s0);
        const y0hi = Math.asinh((GLOBAL.qhi - GLOBAL.med) / s0);
        const r = Math.max(Math.abs(y0lo), Math.abs(y0hi));
        const pad = 0.15 * r;                 // small headroom
        view.ylo = -(r + pad);
        view.yhi = +(r + pad);
      } else {
        const ft = transformFluxAuto(d.flux);
        const ql = percentile(ft, 0.01);
        const qh = percentile(ft, 0.999);
        const span = qh - ql;
        view.ylo = ql - 0.05 * span;
        view.yhi = qh + 0.25 * span;
      }

      drawLegend(); draw();
      const img = document.getElementById('cutout');
      img.src = (d.image && d.image.path) ? d.image.path : "";
    }

    // Baseline absolute transform (gain-independent)
    function transformFluxAbsBase(f) {
      const s0 = 3 * GLOBAL.mad;                // fixed softness
      return f.map(v => Math.asinh((v - GLOBAL.med) / s0));
    }

    const VIS_SPAN = VIS_MAX_NM - VIS_MIN_NM;
    function fitSpanToVisible(center, span) {
      span = Math.max(MIN_X_SPAN, Math.min(span, VIS_SPAN));
      let lo = center - 0.5 * span;
      let hi = center + 0.5 * span;
      if (lo < VIS_MIN_NM) { lo = VIS_MIN_NM; hi = lo + span; }
      if (hi > VIS_MAX_NM) { hi = VIS_MAX_NM; lo = hi - span; }
      return [lo, hi];
    }

    function wavelengthToRGB(nm) {
      // 380–780 nm -> [r,g,b] in 0–255
      let r = 0, g = 0, b = 0, a = 1, t = 0, wl = nm;
      if (wl < 380) wl = 380; if (wl > 780) wl = 780;
      if (wl < 440) { r = -(wl - 440) / (440 - 380); g = 0; b = 1; a = 0.3 + 0.7 * (wl - 380) / (60); }
      else if (wl < 490) { r = 0; g = (wl - 440) / (490 - 440); b = 1; }
      else if (wl < 510) { r = 0; g = 1; b = -(wl - 510) / (510 - 490); }
      else if (wl < 580) { r = (wl - 510) / (580 - 510); g = 1; b = 0; }
      else if (wl < 645) { r = 1; g = -(wl - 645) / (645 - 580); b = 0; }
      else { r = 1; g = 0; b = 0; a = 0.3 + 0.7 * (780 - wl) / (780 - 645); }
      const gamma = 0.8;
      r = Math.round(255 * Math.pow(r * a, gamma));
      g = Math.round(255 * Math.pow(g * a, gamma));
      b = Math.round(255 * Math.pow(b * a, gamma));
      return [r, g, b];
    }
    function rgb(r, g, b) { return `rgb(${r},${g},${b})`; }

    function percentile(a, p) {
      const b = [...a].sort((x, y) => x - y), n = b.length;
      if (n === 0) return 0;
      const i = (n - 1) * p, lo = Math.floor(i), hi = Math.ceil(i), h = i - lo;
      return (1 - h) * b[lo] + h * b[hi];
    }
    function median(a) { return percentile(a, 0.5); }
    function transformFlux(f) {
      // asinh works with negatives and compresses peaks
      const m = median(f);
      const mad = median(f.map(v => Math.abs(v - m))) || 1;
      const s = 3 * mad;                 // softness
      return f.map(v => Math.asinh((v - m) / s));
    }

    function x2px(x) { const w = canvas.clientWidth; return (x - view.xlo) / (view.xhi - view.xlo) * w; }
    function y2px(y) { const h = canvas.clientHeight; return h - (y - view.ylo) / (view.yhi - view.ylo) * h; }

    function drawLegend() {
      const z = Number(zInput.value) || 0;
      legend.textContent = REST_LINES.map(([lab, wlA]) => {
        const obsNm = ((modeSel.value === 'rest') ? wlA : wlA * (1 + z)) * A2NM;
        return `${lab}: ${obsNm.toFixed(1)} nm`;
      }).join('  |  ');
    }

    // === REPLACE your draw() with this ===
    function draw() {
      const d = data[current]; if (!d) return;

      // clamp x-range to visible each draw
      if (typeof clampXToVisible === 'function') {
        const center = 0.5 * (view.xlo + view.xhi);
        const span = (view.xhi - view.xlo);
        [view.xlo, view.xhi] = fitSpanToVisible(center, span);
      }

      const w = canvas.clientWidth, h = canvas.clientHeight;
      const L = 40, R = w - 10, T = 10, B = h - 30, W = R - L, H = B - T;

      const z = Number(zInput.value) || 0;
      const mode = modeSel.value;

      const wlA = d.wavelength_A;
      const wlObsA = (mode === 'rest') ? wlA.map(w => w / (1 + z)) : wlA;
      const X = wlObsA.map(w => w * A2NM); // nm

      const g = parseFloat(gain.value) || 1;
      const fl = (yScaleSel.value === 'abs')
        ? transformFluxAbsBase(d.flux).map(v => v * g)   // baseline asinh, then scale
        : transformFluxAuto(d.flux);


      // mappers over the plotting rect
      const x2 = x => L + (x - view.xlo) / (view.xhi - view.xlo) * W;
      const y2 = y => B - (y - view.ylo) / (view.yhi - view.ylo) * H;

      ctx.clearRect(0, 0, w, h);

      // axes
      ctx.lineWidth = 1; ctx.strokeStyle = '#333';
      ctx.beginPath(); ctx.moveTo(L, T); ctx.lineTo(L, B); ctx.lineTo(R, B); ctx.stroke();

      // spectrum with wavelength-colored segments, clipped to visible band
      let pxPrev = null, pyPrev = null, nmPrev = null;
      const STEP = 1;
      for (let i = 0; i < X.length; i += STEP) {
        const nm = X[i];
        if (nm < view.xlo || nm > view.xhi) { pxPrev = pyPrev = nmPrev = null; continue; }
        const px = x2(nm);
        const py = y2(fl[i]);

        if (pxPrev !== null) {
          const nmMid = 0.5 * (nmPrev + nm);
          const [r, g, b] = wavelengthToRGB(nmMid);
          ctx.strokeStyle = rgb(r, g, b);
          ctx.beginPath(); ctx.moveTo(pxPrev, pyPrev); ctx.lineTo(px, py); ctx.stroke();
        }
        pxPrev = px; pyPrev = py; nmPrev = nm;
      }

      // rest lines + labels (symbol top, nm below)
      if (showLines.checked) {
        ctx.strokeStyle = '#444'; ctx.fillStyle = '#888';
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.font = '10px system-ui, sans-serif';
        for (const [lab, wlA0] of REST_LINES) {
          const xObsNm = ((mode === 'rest') ? wlA0 : wlA0 * (1 + z)) * A2NM;
          if (xObsNm < view.xlo || xObsNm > view.xhi) continue;
          const px = x2(xObsNm);
          ctx.beginPath(); ctx.moveTo(px, T + 2); ctx.lineTo(px, B); ctx.stroke();
          ctx.fillText(lab, px, T); ctx.fillText(`${xObsNm.toFixed(1)} nm`, px, T + 12);
        }
      }
      // labels
      ctx.fillStyle = '#aaa';
      ctx.textAlign = 'left'; ctx.fillText('Flux (arb.)', L - 32, T + 14);
      ctx.textAlign = 'right'; ctx.fillText(mode === 'rest' ? 'Rest wavelength (nm)' : 'Observed wavelength (nm)', R, B + 6);

      // --- hover measuring line ---
      if (hoverNm !== null && hoverNm >= view.xlo && hoverNm <= view.xhi) {
        const w = canvas.clientWidth, h = canvas.clientHeight;
        const L = 40, R = w - 10, T = 10, B = h - 30, W = R - L;
        const x2 = x => L + (x - view.xlo) / (view.xhi - view.xlo) * W;

        const px = x2(hoverNm);

        const [r, g, b] = wavelengthToRGB(hoverNm);
        const col = `rgb(${r},${g},${b})`;

        ctx.save();

        // colored vertical line with a soft glow
        ctx.strokeStyle = col;
        ctx.lineWidth = 1;
        ctx.shadowColor = `rgba(${r},${g},${b},0.6)`;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.moveTo(px, T + 2);
        ctx.lineTo(px, B);
        ctx.stroke();

        // wavelength label (outlined for readability), same color as the line
        const label = `${hoverNm.toFixed(1)} nm`;
        ctx.font = 'bold 14px system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.shadowColor = 'transparent';
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(0,0,0,0.65)';
        ctx.strokeText(label, px, B - 2);
        ctx.fillStyle = col;
        ctx.fillText(label, px, B - 2);

        ctx.restore();
      }
    }


    let dragging = false, lastX = 0, lastY = 0;
    canvas.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mousemove', e => {
      updateHover(e);
      if (dragging) {
        const dx = e.clientX - lastX, dy = e.clientY - lastY; lastX = e.clientX; lastY = e.clientY;
        const w = view.xhi - view.xlo, h = view.yhi - view.ylo;
        const fx = -dx / canvas.clientWidth, fy = dy / canvas.clientHeight;
        view.xlo += fx * w; view.xhi += fx * w; view.ylo += fy * h; view.yhi += fy * h;
      }
      draw();
    });
    canvas.addEventListener('mouseleave', () => { hoverNm = null; draw(); });
    canvas.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; updateHover(e); });
    const MIN_X_SPAN = 5;      // nm
    const MIN_Y_SPAN = 0.02;   // display units after transform

    function zoom1D(lo, hi, center, factor) {
      const span = (hi - lo) * factor;
      return [center - 0.5 * span, center + 0.5 * span];
    }
    function clampSpan(lo, hi, minSpan) {
      if ((hi - lo) < minSpan) {
        const mid = 0.5 * (lo + hi);
        lo = mid - 0.5 * minSpan; hi = mid + 0.5 * minSpan;
      }
      return [lo, hi];
    }

    function updateHover(e) {
      const rect = canvas.getBoundingClientRect();
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const L = 40, R = w - 10, T = 10, B = h - 30;

      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (x >= L && x <= R && y >= T && y <= B) {
        const frac = (x - L) / Math.max(1, (R - L));
        hoverNm = view.xlo + frac * (view.xhi - view.xlo);
      } else {
        hoverNm = null;
      }
    }

    function wheelDir(e) {
      // +1 = scroll down, -1 = scroll up
      if (e.deltaY !== 0) return e.deltaY > 0 ? +1 : -1;
      if ('wheelDelta' in e && e.wheelDelta !== 0) return e.wheelDelta > 0 ? -1 : +1; // legacy inverted
      if ('detail' in e && e.detail !== 0) return e.detail > 0 ? +1 : -1;            // very old FF
      return 0;
    }

    canvas.addEventListener('wheel', e => {
      e.preventDefault();

      const w = canvas.clientWidth, h = canvas.clientHeight;
      const L = 40, R = w - 10, T = 10, B = h - 30, W = R - L, H = B - T;

      const mx = Math.min(1, Math.max(0, (e.clientX - canvas.getBoundingClientRect().left - L) / Math.max(1, W)));
      const my = Math.min(1, Math.max(0, (e.clientY - canvas.getBoundingClientRect().top - T) / Math.max(1, H)));

      const xmid = view.xlo + mx * (view.xhi - view.xlo);
      const ymid = view.yhi - my * (view.yhi - view.ylo);

      const dirY = wheelDir(e);              // -1 up, +1 down
      const dirX = Math.sign(e.deltaX || 0); // -1 left, +1 right
      const ZSTEP = 1.12;
      const factor = dirY > 0 ? ZSTEP : (dirY < 0 ? 1 / ZSTEP : 1);
      const panStep = 0.002;

      if (e.shiftKey) {
        // vertical PAN
        const dyPan = dirY * panStep * (view.yhi - view.ylo);
        view.ylo += dyPan; view.yhi += dyPan;
      } else if (Math.abs(e.deltaX) > Math.abs(e.deltaY) || e.altKey) {
        // horizontal PAN (preserve span)
        const span = (view.xhi - view.xlo);
        const center = 0.5 * (view.xlo + view.xhi) + (dirX || dirY) * panStep * span;
        [view.xlo, view.xhi] = fitSpanToVisible(center, span);
      } else if (factor !== 1) {
        // horizontal ZOOM about cursor (preserve span; allow edge expansion)
        const curSpan = (view.xhi - view.xlo);
        const newSpan = curSpan * factor;          // >1 = zoom OUT, <1 = zoom IN
        [view.xlo, view.xhi] = fitSpanToVisible(xmid, newSpan);
      }
      draw();
    }, { passive: false });



    yScaleSel.addEventListener('change', () => applySelection());
    gain.addEventListener('input', () => {
      gainOut.textContent = '×' + (parseFloat(gain.value) || 1).toFixed(2);
      if (yScaleSel.value === 'abs') {
        const half = 0.5 * (view.yhi - view.ylo);
        view.ylo = -half; view.yhi = half;   // centre around 0
      }
      draw();
    });

    function setStatus(msg) { statusEl.textContent = msg; }

    objSel.addEventListener('change', () => { gain.value = 1; gain.innerHTML = "1"; current = parseInt(objSel.value, 10); applySelection(); });
    modeSel.addEventListener('change', () => { drawLegend(); draw(); });
    applyZBtn.addEventListener('click', () => { drawLegend(); draw(); });
    document.getElementById('open').addEventListener('click', () => fileIn.click());
    fileIn.addEventListener('change', async () => {
      const f = fileIn.files[0]; if (!f) return;
      try {
        const obj = JSON.parse(await f.text()); if (!Array.isArray(obj)) throw new Error('JSON must be an array');
        loadJSON(obj); setStatus(`Loaded ${f.name} with ${obj.length} object(s)`);
      }
      catch (err) { setStatus('Invalid JSON: ' + err.message); }
    });

    fetch('spectra.json').then(r => {
      if (!r.ok) throw new Error('no spectra.json'); return r.json();
    }).then(obj => { loadJSON(obj); setStatus('Loaded spectra.json'); })
      .catch(() => setStatus('No local spectra.json. Use Open JSON.'));

    const showLines = document.getElementById('showLines');
    showLines.addEventListener('change', draw);

    resize();

  </script>
  <div id="cutoutWrap"><img id="cutout" alt="cutout"></div>
</body>

</html>