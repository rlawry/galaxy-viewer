<!doctype html>
<html lang='en'>

<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <title>Galaxy Spectra Redshift Viewer</title>
  <style>
    :root {
      color-scheme: dark light;
    }

    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #0b0b0b;
      color: #e5e5e5;
    }

    header,
    footer {
      padding: 8px 12px;
      background: #111;
      border-bottom: 1px solid #222;
    }

    footer {
      border-top: 1px solid #222;
      border-bottom: none;
    }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    button,
    select,
    input {
      background: #181818;
      color: #ddd;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 6px 8px;
    }

    #canvas {
      display: block;
      width: 100vw;
      height: calc(100vh - 150px);
      background: #0a0a0a;
    }

    .pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #333;
      background: #151515;
    }

    #legend {
      font-size: 12px;
    }

    /* overlay */

    #aladinWrap {
      position: fixed;
      right: 12px;
      bottom: 12px;
      width: 280px;
      height: 280px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #000;
      opacity: .9;
      z-index: 20;
      filter: grayscale(1);
      pointer-events: none;
      /* so canvas interactions still work */
    }

    #aladin {
      width: 100%;
      height: 100%
    }

    /* force grayscale look */
    #aladinWrap {
      filter: grayscale(1);
    }
  </style>
  <link rel="stylesheet" href="https://aladin.cds.unistra.fr/AladinLite/api/v3/latest/aladin.min.css">
</head>

<script src="https://aladin.cds.unistra.fr/AladinLite/api/v3/latest/aladin.min.js"></script>

<body>
  <header>
    <div class='row'>
      <label>Object</label><select id='obj'></select>
      <label>Mode</label>
      <select id='mode'>
        <option value='observed'>Observed</option>
        <option value='rest'>Rest-frame (divide by 1+z)</option>
      </select>
      <label>z</label><input id='z' type='number' step='0.0001' value='0' style='width:110px'>
      <button id='applyZ'>Apply z</button>
      <button id='open'>Open JSON…</button>
      <span class='pill' id='status'>No file loaded</span>
    </div>
  </header>
  <canvas id='canvas'></canvas>
  <style>

  </style>
  <footer>
    <div class='row'>
      <div id='legend'></div>
      <div style='margin-left:auto'><span class='pill'>Vertical lines: key rest wavelengths</span></div>
    </div>
  </footer>
  <input type='file' id='file' accept='.json' style='display:none'>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const objSel = document.getElementById('obj');
    const modeSel = document.getElementById('mode');
    const zInput = document.getElementById('z');
    const applyZBtn = document.getElementById('applyZ');
    const statusEl = document.getElementById('status');
    const openBtn = document.getElementById('open');
    const fileIn = document.getElementById('file');
    const legend = document.getElementById('legend');

    const REST_LINES = [
      //["[O II]", 3727.0],
      ["Hδ", 4101.74],
      ["Hγ", 4340.47],
      ["Hβ", 4861.33],
      //["[O III]", 4958.91],
      //["[O III]", 5006.84],
      ["Mg b", 5175.0],
      ["Na D", 5891.58],
      ["Hα", 6562.80],
      //["[N II]", 6583.45],
      //["[S II]", 6716.44],
      //["[S II]", 6730.82],
      //["Ca K", 3933.66],
      //["Ca H", 3968.47],
    ];
    const A2NM = 0.1;

    let data = []; let view = { xlo: 3500, xhi: 9000, ylo: -1, yhi: 5 }; let current = 0;

    let aladin = null, aladinCat = null;

    const ALADIN_JS = "https://aladin.cds.unistra.fr/AladinLite/api/v3/latest/aladin.min.js";

    function ensureAladin(cb) {
      if (window.A) return cb();
      const s = document.createElement("script");
      s.src = ALADIN_JS; s.async = true;
      s.onload = cb;
      s.onerror = () => console.error("Failed to load Aladin Lite");
      document.head.appendChild(s);
    }

    function initAladin() {
      aladin = A.aladin('#aladin', {
        survey: 'P/DSS2/red',   // DSS2 single-band, looks grayscale
        fov: 0.03,              // ~1.8 arcmin
        showReticle: false,
        showCooGrid: false,
      });
      aladinCat = A.catalog({ name: 'target', color: '#00ff88' });
      aladin.addCatalog(aladinCat);
    }

    function updateAladin() {
      const d = data[current];
      if (!aladin || !d || d.ra_deg == null || d.dec_deg == null) return;
      aladin.gotoPosition(d.ra_deg, d.dec_deg);
      aladin.setFoV(0.03);
      aladinCat.removeAll();
      aladinCat.addSources(A.marker(d.ra_deg, d.dec_deg, { popupTitle: d.name || '' }));
    }



    function resize() {
      const dpr = window.devicePixelRatio || 1; canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr); ctx.setTransform(dpr, 0, 0, dpr, 0, 0); draw();
    }
    window.addEventListener('resize', resize);

    function setStatus(msg) { statusEl.textContent = msg; }

    function loadJSON(obj) {
      data = obj; objSel.innerHTML = '';
      data.forEach((d, i) => {
        const opt = document.createElement('option'); opt.value = i;
        opt.textContent = `${d.name}  z=${d.z ?? '?'}`; objSel.appendChild(opt);
      });
      current = 0; objSel.value = '0'; applySelection();
    }

    function applySelection() {
      const d = data[current];
      const z = Number.isFinite(d.z) ? Number(d.z) : 0;
      zInput.value = z.toFixed(4);

      const ft = transformFlux(d.flux);
      const ql = percentile(ft, 0.01);
      const qh = percentile(ft, 0.999);   // tighter on the top tail
      const span = qh - ql;
      const padTop = 0.25 * span;
      const padBot = 0.05 * span;

      const wl_nm = d.wavelength_A.map(w => w * A2NM);
      view.xlo = Math.min(...wl_nm);
      view.xhi = Math.max(...wl_nm);
      view.ylo = ql - padBot;
      view.yhi = qh + padTop;

      drawLegend();
      draw();
      updateAladin();
    }

    function wavelengthToRGB(nm) {
      // 380–780 nm -> [r,g,b] in 0–255
      let r = 0, g = 0, b = 0, a = 1, t = 0, wl = nm;
      if (wl < 380) wl = 380; if (wl > 780) wl = 780;
      if (wl < 440) { r = -(wl - 440) / (440 - 380); g = 0; b = 1; a = 0.3 + 0.7 * (wl - 380) / (60); }
      else if (wl < 490) { r = 0; g = (wl - 440) / (490 - 440); b = 1; }
      else if (wl < 510) { r = 0; g = 1; b = -(wl - 510) / (510 - 490); }
      else if (wl < 580) { r = (wl - 510) / (580 - 510); g = 1; b = 0; }
      else if (wl < 645) { r = 1; g = -(wl - 645) / (645 - 580); b = 0; }
      else { r = 1; g = 0; b = 0; a = 0.3 + 0.7 * (780 - wl) / (780 - 645); }
      const gamma = 0.8;
      r = Math.round(255 * Math.pow(r * a, gamma));
      g = Math.round(255 * Math.pow(g * a, gamma));
      b = Math.round(255 * Math.pow(b * a, gamma));
      return [r, g, b];
    }
    function rgb(r, g, b) { return `rgb(${r},${g},${b})`; }

    function percentile(a, p) {
      const b = [...a].sort((x, y) => x - y), n = b.length;
      if (n === 0) return 0;
      const i = (n - 1) * p, lo = Math.floor(i), hi = Math.ceil(i), h = i - lo;
      return (1 - h) * b[lo] + h * b[hi];
    }
    function median(a) { return percentile(a, 0.5); }
    function transformFlux(f) {
      // asinh works with negatives and compresses peaks
      const m = median(f);
      const mad = median(f.map(v => Math.abs(v - m))) || 1;
      const s = 3 * mad;                 // softness
      return f.map(v => Math.asinh((v - m) / s));
    }

    function x2px(x) { const w = canvas.clientWidth; return (x - view.xlo) / (view.xhi - view.xlo) * w; }
    function y2px(y) { const h = canvas.clientHeight; return h - (y - view.ylo) / (view.yhi - view.ylo) * h; }

    function drawLegend() {
      const z = Number(zInput.value) || 0;
      legend.textContent = REST_LINES.map(([lab, wlA]) => {
        const obsNm = ((modeSel.value === 'rest') ? wlA : wlA * (1 + z)) * A2NM;
        return `${lab}: ${obsNm.toFixed(1)} nm`;
      }).join('  |  ');
    }

    function draw() {
      const d = data[current]; if (!d) return;
      const wlA = d.wavelength_A;
      const fl = transformFlux(d.flux);
      const z = Number(zInput.value) || 0;
      const mode = modeSel.value;
      const wlObsA = (mode === 'rest') ? wlA.map(w => w / (1 + z)) : wlA;
      const X = wlObsA.map(w => w * A2NM); // nm

      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

      // axes
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#333';
      ctx.beginPath();
      ctx.moveTo(40, 10);
      ctx.lineTo(40, canvas.clientHeight - 30);
      ctx.lineTo(canvas.clientWidth - 10, canvas.clientHeight - 30);
      ctx.stroke();

      // spectrum with wavelength-colored segments
      let pxPrev = null, pyPrev = null, nmPrev = null;
      const STEP = 1; // increase to 2–4 for speed
      for (let i = 0; i < X.length; i += STEP) {
        const px = 40 + (x2px(X[i]) - x2px(view.xlo));
        const py = (y2px(fl[i]) - y2px(view.yhi)) + 10;
        const nm = X[i];

        if (pxPrev !== null) {
          const nmMid = 0.5 * (nmPrev + nm);
          const [r, g, b] = wavelengthToRGB(nmMid);
          ctx.strokeStyle = rgb(r, g, b);
          ctx.beginPath();
          ctx.moveTo(pxPrev, pyPrev);
          ctx.lineTo(px, py);
          ctx.stroke();
        }
        pxPrev = px; pyPrev = py; nmPrev = nm;
      }

      // rest lines + labels (symbol top, nm below)
      ctx.strokeStyle = '#444'; ctx.fillStyle = '#888';
      ctx.textAlign = 'center'; ctx.textBaseline = 'top';
      ctx.font = '10px system-ui, sans-serif';
      for (const [lab, wlA0] of REST_LINES) {
        const xObsNm = ((mode === "rest") ? wlA0 : wlA0 * (1 + z)) * A2NM;
        if (xObsNm < view.xlo || xObsNm > view.xhi) continue;
        const px = 40 + (x2px(xObsNm) - x2px(view.xlo));
        ctx.beginPath();
        ctx.moveTo(px, 12);
        ctx.lineTo(px, canvas.clientHeight - 30);
        ctx.stroke();
        ctx.fillText(lab, px, 10);
        ctx.fillText(`${xObsNm.toFixed(1)} nm`, px, 22);
      }

      // labels
      ctx.fillStyle = '#aaa';
      ctx.textAlign = 'left';
      ctx.fillText('Flux (arb.)', 8, 24);
      ctx.textAlign = "right";
      ctx.fillText(mode === "rest" ? "Rest wavelength (nm)" : "Observed wavelength (nm)",
        canvas.clientWidth - 12, canvas.clientHeight - 10);
    }

    let dragging = false, lastX = 0, lastY = 0;
    canvas.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    window.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mousemove', e => {
      if (!dragging) return;
      const dx = e.clientX - lastX, dy = e.clientY - lastY; lastX = e.clientX; lastY = e.clientY;
      const w = view.xhi - view.xlo, h = view.yhi - view.ylo;
      const fx = -dx / canvas.clientWidth, fy = dy / canvas.clientHeight;
      view.xlo += fx * w; view.xhi += fx * w; view.ylo += fy * h; view.yhi += fy * h; draw();
    });
    canvas.addEventListener('wheel', e => {
      e.preventDefault();
      const s = Math.exp(-Math.sign(e.deltaY) * 0.08);
      const mx = e.clientX / canvas.clientWidth, my = e.clientY / canvas.clientHeight;
      const xmid = view.xlo + mx * (view.xhi - view.xlo), ymid = view.ylo + (1 - my) * (view.yhi - view.ylo);
      view.xlo = xmid + (view.xlo - xmid) * s; view.xhi = xmid + (view.xhi - xmid) / s;
      view.ylo = ymid + (view.ylo - ymid) * s; view.yhi = ymid + (view.yhi - ymid) / s; draw();
    }, { passive: false });
    canvas.addEventListener("click", (e) => {
      const xnm = view.xlo + (e.clientX / canvas.clientWidth) * (view.xhi - view.xlo);
      const y = view.yhi - (e.clientY / canvas.clientHeight) * (view.yhi - view.ylo);
      setStatus(`${modeSel.value === 'rest' ? 'Rest λ' : 'Obs λ'} = ${xnm.toFixed(1)} nm,  Flux = ${y.toFixed(2)}`);
    });

    function setStatus(msg) { statusEl.textContent = msg; }

    objSel.addEventListener('change', () => { current = parseInt(objSel.value, 10); applySelection(); });
    modeSel.addEventListener('change', () => { drawLegend(); draw(); });
    applyZBtn.addEventListener('click', () => { drawLegend(); draw(); });
    document.getElementById('open').addEventListener('click', () => fileIn.click());
    fileIn.addEventListener('change', async () => {
      const f = fileIn.files[0]; if (!f) return;
      try {
        const obj = JSON.parse(await f.text()); if (!Array.isArray(obj)) throw new Error('JSON must be an array');
        loadJSON(obj); setStatus(`Loaded ${f.name} with ${obj.length} object(s)`);
      }
      catch (err) { setStatus('Invalid JSON: ' + err.message); }
    });

    fetch('spectra.json').then(r => {
      if (!r.ok) throw new Error('no spectra.json'); return r.json();
    }).then(obj => { loadJSON(obj); setStatus('Loaded spectra.json'); })
      .catch(() => setStatus('No local spectra.json. Use Open JSON.'));

    window.addEventListener("DOMContentLoaded", () => {
      ensureAladin(() => { initAladin(); updateAladin(); });
    });

    resize();

  </script>
  <div id="aladinWrap">
    <div id="aladin"></div>
  </div>
</body>

</html>